(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('apollo-client'), require('@angular/core'), require('apollo-link'), require('graphql/language/printer'), require('apollo-angular'), require('apollo-cache-inmemory'), require('apollo-cache')) :
    typeof define === 'function' && define.amd ? define('apollo-angular/testing', ['exports', 'apollo-client', '@angular/core', 'apollo-link', 'graphql/language/printer', 'apollo-angular', 'apollo-cache-inmemory', 'apollo-cache'], factory) :
    (factory((global['apollo-angular'] = global['apollo-angular'] || {}, global['apollo-angular'].testing = {}),global.apollo,global.ng.core,global.apolloLink.core,global.printer,global['apollo-angular'],global.apollo.cache.inmemory,global.apolloCache));
}(this, (function (exports,apolloClient,core,apolloLink,printer,apolloAngular,apolloCacheInmemory,apolloCache) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Controller to be injected into tests, that allows for mocking and flushing
     * of operations.
     *
     *
     * @abstract
     */
    var /**
     * Controller to be injected into tests, that allows for mocking and flushing
     * of operations.
     *
     *
     * @abstract
     */ ApolloTestingController = /** @class */ (function () {
        function ApolloTestingController() {
        }
        return ApolloTestingController;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var isApolloError = function (err) {
        return err && err.hasOwnProperty('graphQLErrors');
    };
    var TestOperation = /** @class */ (function () {
        function TestOperation(operation, observer) {
            this.operation = operation;
            this.observer = observer;
        }
        /**
         * @param {?} result
         * @return {?}
         */
        TestOperation.prototype.flush = /**
         * @param {?} result
         * @return {?}
         */
            function (result) {
                if (isApolloError(result)) {
                    this.observer.error(result);
                }
                else {
                    this.observer.next(( /** @type {?} */(result)));
                    this.observer.complete();
                }
            };
        /**
         * @param {?} error
         * @return {?}
         */
        TestOperation.prototype.networkError = /**
         * @param {?} error
         * @return {?}
         */
            function (error) {
                /** @type {?} */
                var apolloError = new apolloClient.ApolloError({
                    networkError: error,
                });
                this.flush(apolloError);
            };
        /**
         * @param {?} errors
         * @return {?}
         */
        TestOperation.prototype.graphqlErrors = /**
         * @param {?} errors
         * @return {?}
         */
            function (errors) {
                this.flush({
                    errors: errors,
                });
            };
        return TestOperation;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * A testing backend for `Apollo`.
     *
     * `ApolloTestingBackend` works by keeping a list of all open operations.
     * As operations come in, they're added to the list. Users can assert that specific
     * operations were made and then flush them. In the end, a verify() method asserts
     * that no unexpected operations were made.
     */
    var ApolloTestingBackend = /** @class */ (function () {
        function ApolloTestingBackend() {
            /**
             * List of pending operations which have not yet been expected.
             */
            this.open = [];
        }
        /**
         * Handle an incoming operation by queueing it in the list of open operations.
         */
        /**
         * Handle an incoming operation by queueing it in the list of open operations.
         * @param {?} op
         * @return {?}
         */
        ApolloTestingBackend.prototype.handle = /**
         * Handle an incoming operation by queueing it in the list of open operations.
         * @param {?} op
         * @return {?}
         */
            function (op) {
                var _this = this;
                return new apolloLink.Observable(function (observer) {
                    /** @type {?} */
                    var testOp = new TestOperation(op, observer);
                    _this.open.push(testOp);
                });
            };
        /**
         * Helper function to search for operations in the list of open operations.
         */
        /**
         * Helper function to search for operations in the list of open operations.
         * @param {?} match
         * @return {?}
         */
        ApolloTestingBackend.prototype._match = /**
         * Helper function to search for operations in the list of open operations.
         * @param {?} match
         * @return {?}
         */
            function (match) {
                var _this = this;
                if (typeof match === 'string') {
                    return this.open.filter(function (testOp) { return testOp.operation.operationName === match; });
                }
                else if (typeof match === 'function') {
                    return this.open.filter(function (testOp) { return match(testOp.operation); });
                }
                else {
                    if (this.isDocumentNode(match)) {
                        return this.open.filter(function (testOp) { return printer.print(testOp.operation.query) === printer.print(match); });
                    }
                    return this.open.filter(function (testOp) { return _this.matchOp(match, testOp); });
                }
            };
        /**
         * @param {?} match
         * @param {?} testOp
         * @return {?}
         */
        ApolloTestingBackend.prototype.matchOp = /**
         * @param {?} match
         * @param {?} testOp
         * @return {?}
         */
            function (match, testOp) {
                /** @type {?} */
                var variables = JSON.stringify(match.variables);
                /** @type {?} */
                var extensions = JSON.stringify(match.extensions);
                /** @type {?} */
                var sameName = this.compare(match.operationName, testOp.operation.operationName);
                /** @type {?} */
                var sameVariables = this.compare(variables, testOp.operation.variables);
                /** @type {?} */
                var sameQuery = printer.print(testOp.operation.query) === printer.print(match.query);
                /** @type {?} */
                var sameExtensions = this.compare(extensions, testOp.operation.extensions);
                return sameName && sameVariables && sameQuery && sameExtensions;
            };
        /**
         * @param {?=} expected
         * @param {?=} value
         * @return {?}
         */
        ApolloTestingBackend.prototype.compare = /**
         * @param {?=} expected
         * @param {?=} value
         * @return {?}
         */
            function (expected, value) {
                /** @type {?} */
                var prepare = function (val) {
                    return typeof val === 'string' ? val : JSON.stringify(val);
                };
                /** @type {?} */
                var received = prepare(value);
                return !expected || received === expected;
            };
        /**
         * Search for operations in the list of open operations, and return all that match
         * without asserting anything about the number of matches.
         */
        /**
         * Search for operations in the list of open operations, and return all that match
         * without asserting anything about the number of matches.
         * @param {?} match
         * @return {?}
         */
        ApolloTestingBackend.prototype.match = /**
         * Search for operations in the list of open operations, and return all that match
         * without asserting anything about the number of matches.
         * @param {?} match
         * @return {?}
         */
            function (match) {
                var _this = this;
                /** @type {?} */
                var results = this._match(match);
                results.forEach(function (result) {
                    /** @type {?} */
                    var index = _this.open.indexOf(result);
                    if (index !== -1) {
                        _this.open.splice(index, 1);
                    }
                });
                return results;
            };
        /**
         * Expect that a single outstanding request matches the given matcher, and return
         * it.
         *
         * operations returned through this API will no longer be in the list of open operations,
         * and thus will not match twice.
         */
        /**
         * Expect that a single outstanding request matches the given matcher, and return
         * it.
         *
         * operations returned through this API will no longer be in the list of open operations,
         * and thus will not match twice.
         * @param {?} match
         * @param {?=} description
         * @return {?}
         */
        ApolloTestingBackend.prototype.expectOne = /**
         * Expect that a single outstanding request matches the given matcher, and return
         * it.
         *
         * operations returned through this API will no longer be in the list of open operations,
         * and thus will not match twice.
         * @param {?} match
         * @param {?=} description
         * @return {?}
         */
            function (match, description) {
                description = description || this.descriptionFromMatcher(match);
                /** @type {?} */
                var matches = this.match(match);
                if (matches.length > 1) {
                    throw new Error("Expected one matching operation for criteria \"" + description + "\", found " + matches.length + " operations.");
                }
                if (matches.length === 0) {
                    throw new Error("Expected one matching operation for criteria \"" + description + "\", found none.");
                }
                return matches[0];
            };
        /**
         * Expect that no outstanding operations match the given matcher, and throw an error
         * if any do.
         */
        /**
         * Expect that no outstanding operations match the given matcher, and throw an error
         * if any do.
         * @param {?} match
         * @param {?=} description
         * @return {?}
         */
        ApolloTestingBackend.prototype.expectNone = /**
         * Expect that no outstanding operations match the given matcher, and throw an error
         * if any do.
         * @param {?} match
         * @param {?=} description
         * @return {?}
         */
            function (match, description) {
                description = description || this.descriptionFromMatcher(match);
                /** @type {?} */
                var matches = this.match(match);
                if (matches.length > 0) {
                    throw new Error("Expected zero matching operations for criteria \"" + description + "\", found " + matches.length + ".");
                }
            };
        /**
         * Validate that there are no outstanding operations.
         */
        /**
         * Validate that there are no outstanding operations.
         * @return {?}
         */
        ApolloTestingBackend.prototype.verify = /**
         * Validate that there are no outstanding operations.
         * @return {?}
         */
            function () {
                /** @type {?} */
                var open = this.open;
                if (open.length > 0) {
                    // Show the methods and URLs of open operations in the error, for convenience.
                    /** @type {?} */
                    var operations = open
                        .map(function (testOp) { return testOp.operation.operationName; })
                        .join(', ');
                    throw new Error("Expected no open operations, found " + open.length + ": " + operations);
                }
            };
        /**
         * @param {?} docOrOp
         * @return {?}
         */
        ApolloTestingBackend.prototype.isDocumentNode = /**
         * @param {?} docOrOp
         * @return {?}
         */
            function (docOrOp) {
                return !(( /** @type {?} */(docOrOp))).operationName;
            };
        /**
         * @param {?} matcher
         * @return {?}
         */
        ApolloTestingBackend.prototype.descriptionFromMatcher = /**
         * @param {?} matcher
         * @return {?}
         */
            function (matcher) {
                if (typeof matcher === 'string') {
                    return "Match operationName: " + matcher;
                }
                else if (typeof matcher === 'object') {
                    if (this.isDocumentNode(matcher)) {
                        return "Match DocumentNode";
                    }
                    /** @type {?} */
                    var name_1 = matcher.operationName || '(any)';
                    /** @type {?} */
                    var variables = JSON.stringify(matcher.variables) || '(any)';
                    return "Match operation: " + name_1 + ", variables: " + variables;
                }
                else {
                    return "Match by function: " + matcher.name;
                }
            };
        ApolloTestingBackend.decorators = [
            { type: core.Injectable }
        ];
        return ApolloTestingBackend;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var APOLLO_TESTING_CACHE = new core.InjectionToken('apollo-angular/testing cache');
    var ApolloTestingModule = /** @class */ (function () {
        function ApolloTestingModule(apollo, backend, cache) {
            apollo.create({
                link: new apolloLink.ApolloLink(function (operation) { return backend.handle(operation); }),
                cache: cache ||
                    new apolloCacheInmemory.InMemoryCache({
                        addTypename: false,
                    }),
            });
        }
        ApolloTestingModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [apolloAngular.ApolloModule],
                        providers: [
                            ApolloTestingBackend,
                            { provide: ApolloTestingController, useExisting: ApolloTestingBackend },
                        ],
                    },] }
        ];
        /** @nocollapse */
        ApolloTestingModule.ctorParameters = function () {
            return [
                { type: apolloAngular.Apollo },
                { type: ApolloTestingBackend },
                { type: apolloCache.ApolloCache, decorators: [{ type: core.Optional }, { type: core.Inject, args: [APOLLO_TESTING_CACHE,] }] }
            ];
        };
        return ApolloTestingModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    exports.ApolloTestingController = ApolloTestingController;
    exports.ApolloTestingModule = ApolloTestingModule;
    exports.APOLLO_TESTING_CACHE = APOLLO_TESTING_CACHE;
    exports.TestOperation = TestOperation;
    exports.ɵa = ApolloTestingBackend;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmcuYXBvbGxvLnRlc3RpbmcudW1kLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9hcG9sbG8tYW5ndWxhci90ZXN0aW5nL2NvbnRyb2xsZXIudHMiLCJuZzovL2Fwb2xsby1hbmd1bGFyL3Rlc3Rpbmcvb3BlcmF0aW9uLnRzIiwibmc6Ly9hcG9sbG8tYW5ndWxhci90ZXN0aW5nL2JhY2tlbmQudHMiLCJuZzovL2Fwb2xsby1hbmd1bGFyL3Rlc3RpbmcvbW9kdWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7T3BlcmF0aW9ufSBmcm9tICdhcG9sbG8tbGluayc7XG5pbXBvcnQge0RvY3VtZW50Tm9kZX0gZnJvbSAnZ3JhcGhxbCc7XG5cbmltcG9ydCB7VGVzdE9wZXJhdGlvbn0gZnJvbSAnLi9vcGVyYXRpb24nO1xuXG5leHBvcnQgdHlwZSBNYXRjaE9wZXJhdGlvbkZuID0gKG9wOiBPcGVyYXRpb24pID0+IGJvb2xlYW47XG5leHBvcnQgdHlwZSBNYXRjaE9wZXJhdGlvbiA9XG4gIHwgc3RyaW5nXG4gIHwgRG9jdW1lbnROb2RlXG4gIHwgT3BlcmF0aW9uXG4gIHwgTWF0Y2hPcGVyYXRpb25GbjtcblxuLyoqXG4gKiBDb250cm9sbGVyIHRvIGJlIGluamVjdGVkIGludG8gdGVzdHMsIHRoYXQgYWxsb3dzIGZvciBtb2NraW5nIGFuZCBmbHVzaGluZ1xuICogb2Ygb3BlcmF0aW9ucy5cbiAqXG4gKlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQXBvbGxvVGVzdGluZ0NvbnRyb2xsZXIge1xuICAvKipcbiAgICogU2VhcmNoIGZvciBvcGVyYXRpb25zIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIHBhcmFtZXRlciwgd2l0aG91dCBhbnkgZXhwZWN0YXRpb25zLlxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IG1hdGNoKG1hdGNoOiBNYXRjaE9wZXJhdGlvbik6IFRlc3RPcGVyYXRpb25bXTtcblxuICAvKipcbiAgICogRXhwZWN0IHRoYXQgYSBzaW5nbGUgIGhhcyBiZWVuIG1hZGUgd2hpY2ggbWF0Y2hlcyB0aGUgZ2l2ZW4gVVJMLCBhbmQgcmV0dXJuIGl0c1xuICAgKiBtb2NrLlxuICAgKlxuICAgKiBJZiBubyBzdWNoICBoYXMgYmVlbiBtYWRlLCBvciBtb3JlIHRoYW4gb25lIHN1Y2ggIGhhcyBiZWVuIG1hZGUsIGZhaWwgd2l0aCBhblxuICAgKiBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZ2l2ZW4gIGRlc2NyaXB0aW9uLCBpZiBhbnkuXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgZXhwZWN0T25lKFxuICAgIG9wZXJhdGlvbk5hbWU6IHN0cmluZyxcbiAgICBkZXNjcmlwdGlvbj86IHN0cmluZyxcbiAgKTogVGVzdE9wZXJhdGlvbjtcblxuICAvKipcbiAgICogRXhwZWN0IHRoYXQgYSBzaW5nbGUgIGhhcyBiZWVuIG1hZGUgd2hpY2ggbWF0Y2hlcyB0aGUgZ2l2ZW4gcGFyYW1ldGVycywgYW5kIHJldHVyblxuICAgKiBpdHMgbW9jay5cbiAgICpcbiAgICogSWYgbm8gc3VjaCAgaGFzIGJlZW4gbWFkZSwgb3IgbW9yZSB0aGFuIG9uZSBzdWNoICBoYXMgYmVlbiBtYWRlLCBmYWlsIHdpdGggYW5cbiAgICogZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGdpdmVuICBkZXNjcmlwdGlvbiwgaWYgYW55LlxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IGV4cGVjdE9uZShvcDogT3BlcmF0aW9uLCBkZXNjcmlwdGlvbj86IHN0cmluZyk6IFRlc3RPcGVyYXRpb247XG5cbiAgLyoqXG4gICAqIEV4cGVjdCB0aGF0IGEgc2luZ2xlICBoYXMgYmVlbiBtYWRlIHdoaWNoIG1hdGNoZXMgdGhlIGdpdmVuIHByZWRpY2F0ZSBmdW5jdGlvbiwgYW5kXG4gICAqIHJldHVybiBpdHMgbW9jay5cbiAgICpcbiAgICogSWYgbm8gc3VjaCAgaGFzIGJlZW4gbWFkZSwgb3IgbW9yZSB0aGFuIG9uZSBzdWNoICBoYXMgYmVlbiBtYWRlLCBmYWlsIHdpdGggYW5cbiAgICogZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGdpdmVuICBkZXNjcmlwdGlvbiwgaWYgYW55LlxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IGV4cGVjdE9uZShcbiAgICBtYXRjaEZuOiBNYXRjaE9wZXJhdGlvbkZuLFxuICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nLFxuICApOiBUZXN0T3BlcmF0aW9uO1xuXG4gIC8qKlxuICAgKiBFeHBlY3QgdGhhdCBhIHNpbmdsZSAgaGFzIGJlZW4gbWFkZSB3aGljaCBtYXRjaGVzIHRoZSBnaXZlbiBjb25kaXRpb24sIGFuZCByZXR1cm5cbiAgICogaXRzIG1vY2suXG4gICAqXG4gICAqIElmIG5vIHN1Y2ggIGhhcyBiZWVuIG1hZGUsIG9yIG1vcmUgdGhhbiBvbmUgc3VjaCAgaGFzIGJlZW4gbWFkZSwgZmFpbCB3aXRoIGFuXG4gICAqIGVycm9yIG1lc3NhZ2UgaW5jbHVkaW5nIHRoZSBnaXZlbiAgZGVzY3JpcHRpb24sIGlmIGFueS5cbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBleHBlY3RPbmUoXG4gICAgbWF0Y2g6IE1hdGNoT3BlcmF0aW9uLFxuICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nLFxuICApOiBUZXN0T3BlcmF0aW9uO1xuXG4gIC8qKlxuICAgKiBFeHBlY3QgdGhhdCBubyBvcGVyYXRpb25zIGhhdmUgYmVlbiBtYWRlIHdoaWNoIG1hdGNoIHRoZSBnaXZlbiBVUkwuXG4gICAqXG4gICAqIElmIGEgbWF0Y2hpbmcgIGhhcyBiZWVuIG1hZGUsIGZhaWwgd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZ2l2ZW5cbiAgICogZGVzY3JpcHRpb24sIGlmIGFueS5cbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBleHBlY3ROb25lKG9wZXJhdGlvbk5hbWU6IHN0cmluZywgZGVzY3JpcHRpb24/OiBzdHJpbmcpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBFeHBlY3QgdGhhdCBubyBvcGVyYXRpb25zIGhhdmUgYmVlbiBtYWRlIHdoaWNoIG1hdGNoIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBJZiBhIG1hdGNoaW5nICBoYXMgYmVlbiBtYWRlLCBmYWlsIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGdpdmVuXG4gICAqIGRlc2NyaXB0aW9uLCBpZiBhbnkuXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgZXhwZWN0Tm9uZShvcDogT3BlcmF0aW9uLCBkZXNjcmlwdGlvbj86IHN0cmluZyk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEV4cGVjdCB0aGF0IG5vIG9wZXJhdGlvbnMgaGF2ZSBiZWVuIG1hZGUgd2hpY2ggbWF0Y2ggdGhlIGdpdmVuIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAgICpcbiAgICogSWYgYSBtYXRjaGluZyAgaGFzIGJlZW4gbWFkZSwgZmFpbCB3aXRoIGFuIGVycm9yIG1lc3NhZ2UgaW5jbHVkaW5nIHRoZSBnaXZlblxuICAgKiBkZXNjcmlwdGlvbiwgaWYgYW55LlxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IGV4cGVjdE5vbmUoXG4gICAgbWF0Y2hGbjogTWF0Y2hPcGVyYXRpb25GbixcbiAgICBkZXNjcmlwdGlvbj86IHN0cmluZyxcbiAgKTogdm9pZDtcblxuICAvKipcbiAgICogRXhwZWN0IHRoYXQgbm8gb3BlcmF0aW9ucyBoYXZlIGJlZW4gbWFkZSB3aGljaCBtYXRjaCB0aGUgZ2l2ZW4gY29uZGl0aW9uLlxuICAgKlxuICAgKiBJZiBhIG1hdGNoaW5nICBoYXMgYmVlbiBtYWRlLCBmYWlsIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGdpdmVuXG4gICAqIGRlc2NyaXB0aW9uLCBpZiBhbnkuXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgZXhwZWN0Tm9uZShtYXRjaDogTWF0Y2hPcGVyYXRpb24sIGRlc2NyaXB0aW9uPzogc3RyaW5nKTogdm9pZDtcblxuICAvKipcbiAgICogVmVyaWZ5IHRoYXQgbm8gdW5tYXRjaGVkIG9wZXJhdGlvbnMgYXJlIG91dHN0YW5kaW5nLlxuICAgKlxuICAgKiBJZiBhbnkgb3BlcmF0aW9ucyBhcmUgb3V0c3RhbmRpbmcsIGZhaWwgd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluZGljYXRpbmcgd2hpY2ggb3BlcmF0aW9ucyB3ZXJlIG5vdFxuICAgKiBoYW5kbGVkLlxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IHZlcmlmeSgpOiB2b2lkO1xufVxuIiwiaW1wb3J0IHtBcG9sbG9FcnJvcn0gZnJvbSAnYXBvbGxvLWNsaWVudCc7XG5pbXBvcnQge09wZXJhdGlvbiwgRmV0Y2hSZXN1bHR9IGZyb20gJ2Fwb2xsby1saW5rJztcbmltcG9ydCB7R3JhcGhRTEVycm9yLCBFeGVjdXRpb25SZXN1bHR9IGZyb20gJ2dyYXBocWwnO1xuaW1wb3J0IHtPYnNlcnZlcn0gZnJvbSAncnhqcyc7XG5cbmNvbnN0IGlzQXBvbGxvRXJyb3IgPSAoZXJyOiBhbnkpOiBlcnIgaXMgQXBvbGxvRXJyb3IgPT5cbiAgZXJyICYmIGVyci5oYXNPd25Qcm9wZXJ0eSgnZ3JhcGhRTEVycm9ycycpO1xuXG5leHBvcnQgY2xhc3MgVGVzdE9wZXJhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBvcGVyYXRpb246IE9wZXJhdGlvbixcbiAgICBwcml2YXRlIG9ic2VydmVyOiBPYnNlcnZlcjxGZXRjaFJlc3VsdD4sXG4gICkge31cblxuICBwdWJsaWMgZmx1c2gocmVzdWx0OiBFeGVjdXRpb25SZXN1bHQgfCBBcG9sbG9FcnJvcik6IHZvaWQge1xuICAgIGlmIChpc0Fwb2xsb0Vycm9yKHJlc3VsdCkpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXIuZXJyb3IocmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vYnNlcnZlci5uZXh0KHJlc3VsdCBhcyBGZXRjaFJlc3VsdCk7XG4gICAgICB0aGlzLm9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG5ldHdvcmtFcnJvcihlcnJvcjogRXJyb3IpOiB2b2lkIHtcbiAgICBjb25zdCBhcG9sbG9FcnJvciA9IG5ldyBBcG9sbG9FcnJvcih7XG4gICAgICBuZXR3b3JrRXJyb3I6IGVycm9yLFxuICAgIH0pO1xuXG4gICAgdGhpcy5mbHVzaChhcG9sbG9FcnJvcik7XG4gIH1cblxuICBwdWJsaWMgZ3JhcGhxbEVycm9ycyhlcnJvcnM6IEdyYXBoUUxFcnJvcltdKTogdm9pZCB7XG4gICAgdGhpcy5mbHVzaCh7XG4gICAgICBlcnJvcnMsXG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge09ic2VydmVyfSBmcm9tICdyeGpzJztcbmltcG9ydCB7XG4gIE9wZXJhdGlvbixcbiAgRmV0Y2hSZXN1bHQsXG4gIE9ic2VydmFibGUgYXMgTGlua09ic2VydmFibGUsXG59IGZyb20gJ2Fwb2xsby1saW5rJztcbmltcG9ydCB7RG9jdW1lbnROb2RlfSBmcm9tICdncmFwaHFsJztcbmltcG9ydCB7cHJpbnR9IGZyb20gJ2dyYXBocWwvbGFuZ3VhZ2UvcHJpbnRlcic7XG5cbmltcG9ydCB7QXBvbGxvVGVzdGluZ0NvbnRyb2xsZXIsIE1hdGNoT3BlcmF0aW9ufSBmcm9tICcuL2NvbnRyb2xsZXInO1xuaW1wb3J0IHtUZXN0T3BlcmF0aW9ufSBmcm9tICcuL29wZXJhdGlvbic7XG5cbi8qKlxuICogQSB0ZXN0aW5nIGJhY2tlbmQgZm9yIGBBcG9sbG9gLlxuICpcbiAqIGBBcG9sbG9UZXN0aW5nQmFja2VuZGAgd29ya3MgYnkga2VlcGluZyBhIGxpc3Qgb2YgYWxsIG9wZW4gb3BlcmF0aW9ucy5cbiAqIEFzIG9wZXJhdGlvbnMgY29tZSBpbiwgdGhleSdyZSBhZGRlZCB0byB0aGUgbGlzdC4gVXNlcnMgY2FuIGFzc2VydCB0aGF0IHNwZWNpZmljXG4gKiBvcGVyYXRpb25zIHdlcmUgbWFkZSBhbmQgdGhlbiBmbHVzaCB0aGVtLiBJbiB0aGUgZW5kLCBhIHZlcmlmeSgpIG1ldGhvZCBhc3NlcnRzXG4gKiB0aGF0IG5vIHVuZXhwZWN0ZWQgb3BlcmF0aW9ucyB3ZXJlIG1hZGUuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBcG9sbG9UZXN0aW5nQmFja2VuZCBpbXBsZW1lbnRzIEFwb2xsb1Rlc3RpbmdDb250cm9sbGVyIHtcbiAgLyoqXG4gICAqIExpc3Qgb2YgcGVuZGluZyBvcGVyYXRpb25zIHdoaWNoIGhhdmUgbm90IHlldCBiZWVuIGV4cGVjdGVkLlxuICAgKi9cbiAgcHJpdmF0ZSBvcGVuOiBUZXN0T3BlcmF0aW9uW10gPSBbXTtcblxuICAvKipcbiAgICogSGFuZGxlIGFuIGluY29taW5nIG9wZXJhdGlvbiBieSBxdWV1ZWluZyBpdCBpbiB0aGUgbGlzdCBvZiBvcGVuIG9wZXJhdGlvbnMuXG4gICAqL1xuICBwdWJsaWMgaGFuZGxlKG9wOiBPcGVyYXRpb24pOiBMaW5rT2JzZXJ2YWJsZTxGZXRjaFJlc3VsdD4ge1xuICAgIHJldHVybiBuZXcgTGlua09ic2VydmFibGUoKG9ic2VydmVyOiBPYnNlcnZlcjxhbnk+KSA9PiB7XG4gICAgICBjb25zdCB0ZXN0T3AgPSBuZXcgVGVzdE9wZXJhdGlvbihvcCwgb2JzZXJ2ZXIpO1xuICAgICAgdGhpcy5vcGVuLnB1c2godGVzdE9wKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gc2VhcmNoIGZvciBvcGVyYXRpb25zIGluIHRoZSBsaXN0IG9mIG9wZW4gb3BlcmF0aW9ucy5cbiAgICovXG4gIHByaXZhdGUgX21hdGNoKG1hdGNoOiBNYXRjaE9wZXJhdGlvbik6IFRlc3RPcGVyYXRpb25bXSB7XG4gICAgaWYgKHR5cGVvZiBtYXRjaCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wZW4uZmlsdGVyKFxuICAgICAgICB0ZXN0T3AgPT4gdGVzdE9wLm9wZXJhdGlvbi5vcGVyYXRpb25OYW1lID09PSBtYXRjaCxcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWF0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wZW4uZmlsdGVyKHRlc3RPcCA9PiBtYXRjaCh0ZXN0T3Aub3BlcmF0aW9uKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmlzRG9jdW1lbnROb2RlKG1hdGNoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVuLmZpbHRlcihcbiAgICAgICAgICB0ZXN0T3AgPT4gcHJpbnQodGVzdE9wLm9wZXJhdGlvbi5xdWVyeSkgPT09IHByaW50KG1hdGNoKSxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMub3Blbi5maWx0ZXIodGVzdE9wID0+IHRoaXMubWF0Y2hPcChtYXRjaCwgdGVzdE9wKSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBtYXRjaE9wKG1hdGNoOiBPcGVyYXRpb24sIHRlc3RPcDogVGVzdE9wZXJhdGlvbik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHZhcmlhYmxlcyA9IEpTT04uc3RyaW5naWZ5KG1hdGNoLnZhcmlhYmxlcyk7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IEpTT04uc3RyaW5naWZ5KG1hdGNoLmV4dGVuc2lvbnMpO1xuXG4gICAgY29uc3Qgc2FtZU5hbWUgPSB0aGlzLmNvbXBhcmUoXG4gICAgICBtYXRjaC5vcGVyYXRpb25OYW1lLFxuICAgICAgdGVzdE9wLm9wZXJhdGlvbi5vcGVyYXRpb25OYW1lLFxuICAgICk7XG4gICAgY29uc3Qgc2FtZVZhcmlhYmxlcyA9IHRoaXMuY29tcGFyZSh2YXJpYWJsZXMsIHRlc3RPcC5vcGVyYXRpb24udmFyaWFibGVzKTtcblxuICAgIGNvbnN0IHNhbWVRdWVyeSA9IHByaW50KHRlc3RPcC5vcGVyYXRpb24ucXVlcnkpID09PSBwcmludChtYXRjaC5xdWVyeSk7XG5cbiAgICBjb25zdCBzYW1lRXh0ZW5zaW9ucyA9IHRoaXMuY29tcGFyZShcbiAgICAgIGV4dGVuc2lvbnMsXG4gICAgICB0ZXN0T3Aub3BlcmF0aW9uLmV4dGVuc2lvbnMsXG4gICAgKTtcblxuICAgIHJldHVybiBzYW1lTmFtZSAmJiBzYW1lVmFyaWFibGVzICYmIHNhbWVRdWVyeSAmJiBzYW1lRXh0ZW5zaW9ucztcbiAgfVxuXG4gIHByaXZhdGUgY29tcGFyZShleHBlY3RlZD86IHN0cmluZywgdmFsdWU/OiBPYmplY3QgfCBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBwcmVwYXJlID0gKHZhbDogYW55KSA9PlxuICAgICAgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyB2YWwgOiBKU09OLnN0cmluZ2lmeSh2YWwpO1xuICAgIGNvbnN0IHJlY2VpdmVkID0gcHJlcGFyZSh2YWx1ZSk7XG5cbiAgICByZXR1cm4gIWV4cGVjdGVkIHx8IHJlY2VpdmVkID09PSBleHBlY3RlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWFyY2ggZm9yIG9wZXJhdGlvbnMgaW4gdGhlIGxpc3Qgb2Ygb3BlbiBvcGVyYXRpb25zLCBhbmQgcmV0dXJuIGFsbCB0aGF0IG1hdGNoXG4gICAqIHdpdGhvdXQgYXNzZXJ0aW5nIGFueXRoaW5nIGFib3V0IHRoZSBudW1iZXIgb2YgbWF0Y2hlcy5cbiAgICovXG4gIHB1YmxpYyBtYXRjaChtYXRjaDogTWF0Y2hPcGVyYXRpb24pOiBUZXN0T3BlcmF0aW9uW10ge1xuICAgIGNvbnN0IHJlc3VsdHMgPSB0aGlzLl9tYXRjaChtYXRjaCk7XG5cbiAgICByZXN1bHRzLmZvckVhY2gocmVzdWx0ID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5vcGVuLmluZGV4T2YocmVzdWx0KTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5vcGVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogRXhwZWN0IHRoYXQgYSBzaW5nbGUgb3V0c3RhbmRpbmcgcmVxdWVzdCBtYXRjaGVzIHRoZSBnaXZlbiBtYXRjaGVyLCBhbmQgcmV0dXJuXG4gICAqIGl0LlxuICAgKlxuICAgKiBvcGVyYXRpb25zIHJldHVybmVkIHRocm91Z2ggdGhpcyBBUEkgd2lsbCBubyBsb25nZXIgYmUgaW4gdGhlIGxpc3Qgb2Ygb3BlbiBvcGVyYXRpb25zLFxuICAgKiBhbmQgdGh1cyB3aWxsIG5vdCBtYXRjaCB0d2ljZS5cbiAgICovXG4gIHB1YmxpYyBleHBlY3RPbmUobWF0Y2g6IE1hdGNoT3BlcmF0aW9uLCBkZXNjcmlwdGlvbj86IHN0cmluZyk6IFRlc3RPcGVyYXRpb24ge1xuICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb24gfHwgdGhpcy5kZXNjcmlwdGlvbkZyb21NYXRjaGVyKG1hdGNoKTtcbiAgICBjb25zdCBtYXRjaGVzID0gdGhpcy5tYXRjaChtYXRjaCk7XG4gICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRXhwZWN0ZWQgb25lIG1hdGNoaW5nIG9wZXJhdGlvbiBmb3IgY3JpdGVyaWEgXCIke2Rlc2NyaXB0aW9ufVwiLCBmb3VuZCAke1xuICAgICAgICAgIG1hdGNoZXMubGVuZ3RoXG4gICAgICAgIH0gb3BlcmF0aW9ucy5gLFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBFeHBlY3RlZCBvbmUgbWF0Y2hpbmcgb3BlcmF0aW9uIGZvciBjcml0ZXJpYSBcIiR7ZGVzY3JpcHRpb259XCIsIGZvdW5kIG5vbmUuYCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBtYXRjaGVzWzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cGVjdCB0aGF0IG5vIG91dHN0YW5kaW5nIG9wZXJhdGlvbnMgbWF0Y2ggdGhlIGdpdmVuIG1hdGNoZXIsIGFuZCB0aHJvdyBhbiBlcnJvclxuICAgKiBpZiBhbnkgZG8uXG4gICAqL1xuICBwdWJsaWMgZXhwZWN0Tm9uZShtYXRjaDogTWF0Y2hPcGVyYXRpb24sIGRlc2NyaXB0aW9uPzogc3RyaW5nKTogdm9pZCB7XG4gICAgZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbiB8fCB0aGlzLmRlc2NyaXB0aW9uRnJvbU1hdGNoZXIobWF0Y2gpO1xuICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLm1hdGNoKG1hdGNoKTtcbiAgICBpZiAobWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBFeHBlY3RlZCB6ZXJvIG1hdGNoaW5nIG9wZXJhdGlvbnMgZm9yIGNyaXRlcmlhIFwiJHtkZXNjcmlwdGlvbn1cIiwgZm91bmQgJHtcbiAgICAgICAgICBtYXRjaGVzLmxlbmd0aFxuICAgICAgICB9LmAsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB0aGF0IHRoZXJlIGFyZSBubyBvdXRzdGFuZGluZyBvcGVyYXRpb25zLlxuICAgKi9cbiAgcHVibGljIHZlcmlmeSgpOiB2b2lkIHtcbiAgICBjb25zdCBvcGVuID0gdGhpcy5vcGVuO1xuXG4gICAgaWYgKG9wZW4ubGVuZ3RoID4gMCkge1xuICAgICAgLy8gU2hvdyB0aGUgbWV0aG9kcyBhbmQgVVJMcyBvZiBvcGVuIG9wZXJhdGlvbnMgaW4gdGhlIGVycm9yLCBmb3IgY29udmVuaWVuY2UuXG4gICAgICBjb25zdCBvcGVyYXRpb25zID0gb3BlblxuICAgICAgICAubWFwKHRlc3RPcCA9PiB0ZXN0T3Aub3BlcmF0aW9uLm9wZXJhdGlvbk5hbWUpXG4gICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRXhwZWN0ZWQgbm8gb3BlbiBvcGVyYXRpb25zLCBmb3VuZCAke29wZW4ubGVuZ3RofTogJHtvcGVyYXRpb25zfWAsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaXNEb2N1bWVudE5vZGUoXG4gICAgZG9jT3JPcDogRG9jdW1lbnROb2RlIHwgT3BlcmF0aW9uLFxuICApOiBkb2NPck9wIGlzIERvY3VtZW50Tm9kZSB7XG4gICAgcmV0dXJuICEoZG9jT3JPcCBhcyBPcGVyYXRpb24pLm9wZXJhdGlvbk5hbWU7XG4gIH1cblxuICBwcml2YXRlIGRlc2NyaXB0aW9uRnJvbU1hdGNoZXIobWF0Y2hlcjogTWF0Y2hPcGVyYXRpb24pOiBzdHJpbmcge1xuICAgIGlmICh0eXBlb2YgbWF0Y2hlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBgTWF0Y2ggb3BlcmF0aW9uTmFtZTogJHttYXRjaGVyfWA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWF0Y2hlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICh0aGlzLmlzRG9jdW1lbnROb2RlKG1hdGNoZXIpKSB7XG4gICAgICAgIHJldHVybiBgTWF0Y2ggRG9jdW1lbnROb2RlYDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmFtZSA9IG1hdGNoZXIub3BlcmF0aW9uTmFtZSB8fCAnKGFueSknO1xuICAgICAgY29uc3QgdmFyaWFibGVzID0gSlNPTi5zdHJpbmdpZnkobWF0Y2hlci52YXJpYWJsZXMpIHx8ICcoYW55KSc7XG5cbiAgICAgIHJldHVybiBgTWF0Y2ggb3BlcmF0aW9uOiAke25hbWV9LCB2YXJpYWJsZXM6ICR7dmFyaWFibGVzfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgTWF0Y2ggYnkgZnVuY3Rpb246ICR7bWF0Y2hlci5uYW1lfWA7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQge0Fwb2xsb01vZHVsZSwgQXBvbGxvfSBmcm9tICdhcG9sbG8tYW5ndWxhcic7XG5pbXBvcnQge0Fwb2xsb0xpbmt9IGZyb20gJ2Fwb2xsby1saW5rJztcbmltcG9ydCB7SW5NZW1vcnlDYWNoZX0gZnJvbSAnYXBvbGxvLWNhY2hlLWlubWVtb3J5JztcbmltcG9ydCB7QXBvbGxvQ2FjaGV9IGZyb20gJ2Fwb2xsby1jYWNoZSc7XG5pbXBvcnQge05nTW9kdWxlLCBJbmplY3Rpb25Ub2tlbiwgSW5qZWN0LCBPcHRpb25hbH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7QXBvbGxvVGVzdGluZ0NvbnRyb2xsZXJ9IGZyb20gJy4vY29udHJvbGxlcic7XG5pbXBvcnQge0Fwb2xsb1Rlc3RpbmdCYWNrZW5kfSBmcm9tICcuL2JhY2tlbmQnO1xuXG5leHBvcnQgY29uc3QgQVBPTExPX1RFU1RJTkdfQ0FDSEUgPSBuZXcgSW5qZWN0aW9uVG9rZW48QXBvbGxvQ2FjaGU8YW55Pj4oXG4gICdhcG9sbG8tYW5ndWxhci90ZXN0aW5nIGNhY2hlJyxcbik7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtBcG9sbG9Nb2R1bGVdLFxuICBwcm92aWRlcnM6IFtcbiAgICBBcG9sbG9UZXN0aW5nQmFja2VuZCxcbiAgICB7cHJvdmlkZTogQXBvbGxvVGVzdGluZ0NvbnRyb2xsZXIsIHVzZUV4aXN0aW5nOiBBcG9sbG9UZXN0aW5nQmFja2VuZH0sXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIEFwb2xsb1Rlc3RpbmdNb2R1bGUge1xuICBjb25zdHJ1Y3RvcihcbiAgICBhcG9sbG86IEFwb2xsbyxcbiAgICBiYWNrZW5kOiBBcG9sbG9UZXN0aW5nQmFja2VuZCxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoQVBPTExPX1RFU1RJTkdfQ0FDSEUpXG4gICAgY2FjaGU/OiBBcG9sbG9DYWNoZTxhbnk+LFxuICApIHtcbiAgICBhcG9sbG8uY3JlYXRlKHtcbiAgICAgIGxpbms6IG5ldyBBcG9sbG9MaW5rKG9wZXJhdGlvbiA9PiBiYWNrZW5kLmhhbmRsZShvcGVyYXRpb24pKSxcbiAgICAgIGNhY2hlOlxuICAgICAgICBjYWNoZSB8fFxuICAgICAgICBuZXcgSW5NZW1vcnlDYWNoZSh7XG4gICAgICAgICAgYWRkVHlwZW5hbWU6IGZhbHNlLFxuICAgICAgICB9KSxcbiAgICB9KTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkFwb2xsb0Vycm9yIiwiTGlua09ic2VydmFibGUiLCJwcmludCIsIkluamVjdGFibGUiLCJJbmplY3Rpb25Ub2tlbiIsIkFwb2xsb0xpbmsiLCJJbk1lbW9yeUNhY2hlIiwiTmdNb2R1bGUiLCJBcG9sbG9Nb2R1bGUiLCJBcG9sbG8iLCJBcG9sbG9DYWNoZSIsIk9wdGlvbmFsIiwiSW5qZWN0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQTs7Ozs7OztRQUFBO1NBNkZDO1FBQUQsOEJBQUM7SUFBRCxDQUFDOzs7Ozs7QUMvR0Q7UUFLTSxhQUFhLEdBQUcsVUFBQyxHQUFRO1FBQzdCLE9BQUEsR0FBRyxJQUFJLEdBQUcsQ0FBQyxjQUFjLENBQUMsZUFBZSxDQUFDO0lBQTFDLENBQTBDOztRQUcxQyx1QkFDUyxTQUFvQixFQUNuQixRQUErQjtZQURoQyxjQUFTLEdBQVQsU0FBUyxDQUFXO1lBQ25CLGFBQVEsR0FBUixRQUFRLENBQXVCO1NBQ3JDOzs7OztRQUVHLDZCQUFLOzs7O1lBQVosVUFBYSxNQUFxQztnQkFDaEQsSUFBSSxhQUFhLENBQUMsTUFBTSxDQUFDLEVBQUU7b0JBQ3pCLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2lCQUM3QjtxQkFBTTtvQkFDTCxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksb0JBQUMsTUFBTSxHQUFnQixDQUFDO29CQUMxQyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxDQUFDO2lCQUMxQjthQUNGOzs7OztRQUVNLG9DQUFZOzs7O1lBQW5CLFVBQW9CLEtBQVk7O29CQUN4QixXQUFXLEdBQUcsSUFBSUEsd0JBQVcsQ0FBQztvQkFDbEMsWUFBWSxFQUFFLEtBQUs7aUJBQ3BCLENBQUM7Z0JBRUYsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQzthQUN6Qjs7Ozs7UUFFTSxxQ0FBYTs7OztZQUFwQixVQUFxQixNQUFzQjtnQkFDekMsSUFBSSxDQUFDLEtBQUssQ0FBQztvQkFDVCxNQUFNLFFBQUE7aUJBQ1AsQ0FBQyxDQUFDO2FBQ0o7UUFDSCxvQkFB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