{"version":3,"file":"ng.apollo.testing.umd.js.map","sources":["ng://apollo-angular/testing/controller.ts","ng://apollo-angular/testing/operation.ts","ng://apollo-angular/testing/backend.ts","ng://apollo-angular/testing/module.ts"],"sourcesContent":["import {Operation} from 'apollo-link';\nimport {DocumentNode} from 'graphql';\n\nimport {TestOperation} from './operation';\n\nexport type MatchOperationFn = (op: Operation) => boolean;\nexport type MatchOperation =\n  | string\n  | DocumentNode\n  | Operation\n  | MatchOperationFn;\n\n/**\n * Controller to be injected into tests, that allows for mocking and flushing\n * of operations.\n *\n *\n */\nexport abstract class ApolloTestingController {\n  /**\n   * Search for operations that match the given parameter, without any expectations.\n   */\n  public abstract match(match: MatchOperation): TestOperation[];\n\n  /**\n   * Expect that a single  has been made which matches the given URL, and return its\n   * mock.\n   *\n   * If no such  has been made, or more than one such  has been made, fail with an\n   * error message including the given  description, if any.\n   */\n  public abstract expectOne(\n    operationName: string,\n    description?: string,\n  ): TestOperation;\n\n  /**\n   * Expect that a single  has been made which matches the given parameters, and return\n   * its mock.\n   *\n   * If no such  has been made, or more than one such  has been made, fail with an\n   * error message including the given  description, if any.\n   */\n  public abstract expectOne(op: Operation, description?: string): TestOperation;\n\n  /**\n   * Expect that a single  has been made which matches the given predicate function, and\n   * return its mock.\n   *\n   * If no such  has been made, or more than one such  has been made, fail with an\n   * error message including the given  description, if any.\n   */\n  public abstract expectOne(\n    matchFn: MatchOperationFn,\n    description?: string,\n  ): TestOperation;\n\n  /**\n   * Expect that a single  has been made which matches the given condition, and return\n   * its mock.\n   *\n   * If no such  has been made, or more than one such  has been made, fail with an\n   * error message including the given  description, if any.\n   */\n  public abstract expectOne(\n    match: MatchOperation,\n    description?: string,\n  ): TestOperation;\n\n  /**\n   * Expect that no operations have been made which match the given URL.\n   *\n   * If a matching  has been made, fail with an error message including the given\n   * description, if any.\n   */\n  public abstract expectNone(operationName: string, description?: string): void;\n\n  /**\n   * Expect that no operations have been made which match the given parameters.\n   *\n   * If a matching  has been made, fail with an error message including the given\n   * description, if any.\n   */\n  public abstract expectNone(op: Operation, description?: string): void;\n\n  /**\n   * Expect that no operations have been made which match the given predicate function.\n   *\n   * If a matching  has been made, fail with an error message including the given\n   * description, if any.\n   */\n  public abstract expectNone(\n    matchFn: MatchOperationFn,\n    description?: string,\n  ): void;\n\n  /**\n   * Expect that no operations have been made which match the given condition.\n   *\n   * If a matching  has been made, fail with an error message including the given\n   * description, if any.\n   */\n  public abstract expectNone(match: MatchOperation, description?: string): void;\n\n  /**\n   * Verify that no unmatched operations are outstanding.\n   *\n   * If any operations are outstanding, fail with an error message indicating which operations were not\n   * handled.\n   */\n  public abstract verify(): void;\n}\n","import {ApolloError} from 'apollo-client';\nimport {Operation, FetchResult} from 'apollo-link';\nimport {GraphQLError, ExecutionResult} from 'graphql';\nimport {Observer} from 'rxjs';\n\nconst isApolloError = (err: any): err is ApolloError =>\n  err && err.hasOwnProperty('graphQLErrors');\n\nexport class TestOperation {\n  constructor(\n    public operation: Operation,\n    private observer: Observer<FetchResult>,\n  ) {}\n\n  public flush(result: ExecutionResult | ApolloError): void {\n    if (isApolloError(result)) {\n      this.observer.error(result);\n    } else {\n      this.observer.next(result as FetchResult);\n      this.observer.complete();\n    }\n  }\n\n  public networkError(error: Error): void {\n    const apolloError = new ApolloError({\n      networkError: error,\n    });\n\n    this.flush(apolloError);\n  }\n\n  public graphqlErrors(errors: GraphQLError[]): void {\n    this.flush({\n      errors,\n    });\n  }\n}\n","import {Injectable} from '@angular/core';\nimport {Observer} from 'rxjs';\nimport {\n  Operation,\n  FetchResult,\n  Observable as LinkObservable,\n} from 'apollo-link';\nimport {DocumentNode} from 'graphql';\nimport {print} from 'graphql/language/printer';\n\nimport {ApolloTestingController, MatchOperation} from './controller';\nimport {TestOperation} from './operation';\n\n/**\n * A testing backend for `Apollo`.\n *\n * `ApolloTestingBackend` works by keeping a list of all open operations.\n * As operations come in, they're added to the list. Users can assert that specific\n * operations were made and then flush them. In the end, a verify() method asserts\n * that no unexpected operations were made.\n */\n@Injectable()\nexport class ApolloTestingBackend implements ApolloTestingController {\n  /**\n   * List of pending operations which have not yet been expected.\n   */\n  private open: TestOperation[] = [];\n\n  /**\n   * Handle an incoming operation by queueing it in the list of open operations.\n   */\n  public handle(op: Operation): LinkObservable<FetchResult> {\n    return new LinkObservable((observer: Observer<any>) => {\n      const testOp = new TestOperation(op, observer);\n      this.open.push(testOp);\n    });\n  }\n\n  /**\n   * Helper function to search for operations in the list of open operations.\n   */\n  private _match(match: MatchOperation): TestOperation[] {\n    if (typeof match === 'string') {\n      return this.open.filter(\n        testOp => testOp.operation.operationName === match,\n      );\n    } else if (typeof match === 'function') {\n      return this.open.filter(testOp => match(testOp.operation));\n    } else {\n      if (this.isDocumentNode(match)) {\n        return this.open.filter(\n          testOp => print(testOp.operation.query) === print(match),\n        );\n      }\n\n      return this.open.filter(testOp => this.matchOp(match, testOp));\n    }\n  }\n\n  private matchOp(match: Operation, testOp: TestOperation): boolean {\n    const variables = JSON.stringify(match.variables);\n    const extensions = JSON.stringify(match.extensions);\n\n    const sameName = this.compare(\n      match.operationName,\n      testOp.operation.operationName,\n    );\n    const sameVariables = this.compare(variables, testOp.operation.variables);\n\n    const sameQuery = print(testOp.operation.query) === print(match.query);\n\n    const sameExtensions = this.compare(\n      extensions,\n      testOp.operation.extensions,\n    );\n\n    return sameName && sameVariables && sameQuery && sameExtensions;\n  }\n\n  private compare(expected?: string, value?: Object | string): boolean {\n    const prepare = (val: any) =>\n      typeof val === 'string' ? val : JSON.stringify(val);\n    const received = prepare(value);\n\n    return !expected || received === expected;\n  }\n\n  /**\n   * Search for operations in the list of open operations, and return all that match\n   * without asserting anything about the number of matches.\n   */\n  public match(match: MatchOperation): TestOperation[] {\n    const results = this._match(match);\n\n    results.forEach(result => {\n      const index = this.open.indexOf(result);\n      if (index !== -1) {\n        this.open.splice(index, 1);\n      }\n    });\n    return results;\n  }\n\n  /**\n   * Expect that a single outstanding request matches the given matcher, and return\n   * it.\n   *\n   * operations returned through this API will no longer be in the list of open operations,\n   * and thus will not match twice.\n   */\n  public expectOne(match: MatchOperation, description?: string): TestOperation {\n    description = description || this.descriptionFromMatcher(match);\n    const matches = this.match(match);\n    if (matches.length > 1) {\n      throw new Error(\n        `Expected one matching operation for criteria \"${description}\", found ${\n          matches.length\n        } operations.`,\n      );\n    }\n    if (matches.length === 0) {\n      throw new Error(\n        `Expected one matching operation for criteria \"${description}\", found none.`,\n      );\n    }\n    return matches[0];\n  }\n\n  /**\n   * Expect that no outstanding operations match the given matcher, and throw an error\n   * if any do.\n   */\n  public expectNone(match: MatchOperation, description?: string): void {\n    description = description || this.descriptionFromMatcher(match);\n    const matches = this.match(match);\n    if (matches.length > 0) {\n      throw new Error(\n        `Expected zero matching operations for criteria \"${description}\", found ${\n          matches.length\n        }.`,\n      );\n    }\n  }\n\n  /**\n   * Validate that there are no outstanding operations.\n   */\n  public verify(): void {\n    const open = this.open;\n\n    if (open.length > 0) {\n      // Show the methods and URLs of open operations in the error, for convenience.\n      const operations = open\n        .map(testOp => testOp.operation.operationName)\n        .join(', ');\n      throw new Error(\n        `Expected no open operations, found ${open.length}: ${operations}`,\n      );\n    }\n  }\n\n  private isDocumentNode(\n    docOrOp: DocumentNode | Operation,\n  ): docOrOp is DocumentNode {\n    return !(docOrOp as Operation).operationName;\n  }\n\n  private descriptionFromMatcher(matcher: MatchOperation): string {\n    if (typeof matcher === 'string') {\n      return `Match operationName: ${matcher}`;\n    } else if (typeof matcher === 'object') {\n      if (this.isDocumentNode(matcher)) {\n        return `Match DocumentNode`;\n      }\n\n      const name = matcher.operationName || '(any)';\n      const variables = JSON.stringify(matcher.variables) || '(any)';\n\n      return `Match operation: ${name}, variables: ${variables}`;\n    } else {\n      return `Match by function: ${matcher.name}`;\n    }\n  }\n}\n","import {ApolloModule, Apollo} from 'apollo-angular';\nimport {ApolloLink} from 'apollo-link';\nimport {InMemoryCache} from 'apollo-cache-inmemory';\nimport {ApolloCache} from 'apollo-cache';\nimport {NgModule, InjectionToken, Inject, Optional} from '@angular/core';\n\nimport {ApolloTestingController} from './controller';\nimport {ApolloTestingBackend} from './backend';\n\nexport const APOLLO_TESTING_CACHE = new InjectionToken<ApolloCache<any>>(\n  'apollo-angular/testing cache',\n);\n\n@NgModule({\n  imports: [ApolloModule],\n  providers: [\n    ApolloTestingBackend,\n    {provide: ApolloTestingController, useExisting: ApolloTestingBackend},\n  ],\n})\nexport class ApolloTestingModule {\n  constructor(\n    apollo: Apollo,\n    backend: ApolloTestingBackend,\n    @Optional()\n    @Inject(APOLLO_TESTING_CACHE)\n    cache?: ApolloCache<any>,\n  ) {\n    apollo.create({\n      link: new ApolloLink(operation => backend.handle(operation)),\n      cache:\n        cache ||\n        new InMemoryCache({\n          addTypename: false,\n        }),\n    });\n  }\n}\n"],"names":["ApolloError","LinkObservable","print","Injectable","InjectionToken","ApolloLink","InMemoryCache","NgModule","ApolloModule","Apollo","ApolloCache","Optional","Inject"],"mappings":"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"}
