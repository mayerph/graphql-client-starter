import { ApolloError } from 'apollo-client';
import { Injectable, NgModule, InjectionToken, Inject, Optional } from '@angular/core';
import { Observable, ApolloLink } from 'apollo-link';
import { print } from 'graphql/language/printer';
import { ApolloModule, Apollo } from 'apollo-angular';
import { InMemoryCache } from 'apollo-cache-inmemory';
import { ApolloCache } from 'apollo-cache';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Controller to be injected into tests, that allows for mocking and flushing
 * of operations.
 *
 *
 * @abstract
 */
class ApolloTestingController {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const isApolloError = (err) => err && err.hasOwnProperty('graphQLErrors');
class TestOperation {
    /**
     * @param {?} operation
     * @param {?} observer
     */
    constructor(operation, observer) {
        this.operation = operation;
        this.observer = observer;
    }
    /**
     * @param {?} result
     * @return {?}
     */
    flush(result) {
        if (isApolloError(result)) {
            this.observer.error(result);
        }
        else {
            this.observer.next((/** @type {?} */ (result)));
            this.observer.complete();
        }
    }
    /**
     * @param {?} error
     * @return {?}
     */
    networkError(error) {
        /** @type {?} */
        const apolloError = new ApolloError({
            networkError: error,
        });
        this.flush(apolloError);
    }
    /**
     * @param {?} errors
     * @return {?}
     */
    graphqlErrors(errors) {
        this.flush({
            errors,
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * A testing backend for `Apollo`.
 *
 * `ApolloTestingBackend` works by keeping a list of all open operations.
 * As operations come in, they're added to the list. Users can assert that specific
 * operations were made and then flush them. In the end, a verify() method asserts
 * that no unexpected operations were made.
 */
class ApolloTestingBackend {
    constructor() {
        /**
         * List of pending operations which have not yet been expected.
         */
        this.open = [];
    }
    /**
     * Handle an incoming operation by queueing it in the list of open operations.
     * @param {?} op
     * @return {?}
     */
    handle(op) {
        return new Observable((observer) => {
            /** @type {?} */
            const testOp = new TestOperation(op, observer);
            this.open.push(testOp);
        });
    }
    /**
     * Helper function to search for operations in the list of open operations.
     * @param {?} match
     * @return {?}
     */
    _match(match) {
        if (typeof match === 'string') {
            return this.open.filter(testOp => testOp.operation.operationName === match);
        }
        else if (typeof match === 'function') {
            return this.open.filter(testOp => match(testOp.operation));
        }
        else {
            if (this.isDocumentNode(match)) {
                return this.open.filter(testOp => print(testOp.operation.query) === print(match));
            }
            return this.open.filter(testOp => this.matchOp(match, testOp));
        }
    }
    /**
     * @param {?} match
     * @param {?} testOp
     * @return {?}
     */
    matchOp(match, testOp) {
        /** @type {?} */
        const variables = JSON.stringify(match.variables);
        /** @type {?} */
        const extensions = JSON.stringify(match.extensions);
        /** @type {?} */
        const sameName = this.compare(match.operationName, testOp.operation.operationName);
        /** @type {?} */
        const sameVariables = this.compare(variables, testOp.operation.variables);
        /** @type {?} */
        const sameQuery = print(testOp.operation.query) === print(match.query);
        /** @type {?} */
        const sameExtensions = this.compare(extensions, testOp.operation.extensions);
        return sameName && sameVariables && sameQuery && sameExtensions;
    }
    /**
     * @param {?=} expected
     * @param {?=} value
     * @return {?}
     */
    compare(expected, value) {
        /** @type {?} */
        const prepare = (val) => typeof val === 'string' ? val : JSON.stringify(val);
        /** @type {?} */
        const received = prepare(value);
        return !expected || received === expected;
    }
    /**
     * Search for operations in the list of open operations, and return all that match
     * without asserting anything about the number of matches.
     * @param {?} match
     * @return {?}
     */
    match(match) {
        /** @type {?} */
        const results = this._match(match);
        results.forEach(result => {
            /** @type {?} */
            const index = this.open.indexOf(result);
            if (index !== -1) {
                this.open.splice(index, 1);
            }
        });
        return results;
    }
    /**
     * Expect that a single outstanding request matches the given matcher, and return
     * it.
     *
     * operations returned through this API will no longer be in the list of open operations,
     * and thus will not match twice.
     * @param {?} match
     * @param {?=} description
     * @return {?}
     */
    expectOne(match, description) {
        description = description || this.descriptionFromMatcher(match);
        /** @type {?} */
        const matches = this.match(match);
        if (matches.length > 1) {
            throw new Error(`Expected one matching operation for criteria "${description}", found ${matches.length} operations.`);
        }
        if (matches.length === 0) {
            throw new Error(`Expected one matching operation for criteria "${description}", found none.`);
        }
        return matches[0];
    }
    /**
     * Expect that no outstanding operations match the given matcher, and throw an error
     * if any do.
     * @param {?} match
     * @param {?=} description
     * @return {?}
     */
    expectNone(match, description) {
        description = description || this.descriptionFromMatcher(match);
        /** @type {?} */
        const matches = this.match(match);
        if (matches.length > 0) {
            throw new Error(`Expected zero matching operations for criteria "${description}", found ${matches.length}.`);
        }
    }
    /**
     * Validate that there are no outstanding operations.
     * @return {?}
     */
    verify() {
        /** @type {?} */
        const open = this.open;
        if (open.length > 0) {
            // Show the methods and URLs of open operations in the error, for convenience.
            /** @type {?} */
            const operations = open
                .map(testOp => testOp.operation.operationName)
                .join(', ');
            throw new Error(`Expected no open operations, found ${open.length}: ${operations}`);
        }
    }
    /**
     * @param {?} docOrOp
     * @return {?}
     */
    isDocumentNode(docOrOp) {
        return !((/** @type {?} */ (docOrOp))).operationName;
    }
    /**
     * @param {?} matcher
     * @return {?}
     */
    descriptionFromMatcher(matcher) {
        if (typeof matcher === 'string') {
            return `Match operationName: ${matcher}`;
        }
        else if (typeof matcher === 'object') {
            if (this.isDocumentNode(matcher)) {
                return `Match DocumentNode`;
            }
            /** @type {?} */
            const name = matcher.operationName || '(any)';
            /** @type {?} */
            const variables = JSON.stringify(matcher.variables) || '(any)';
            return `Match operation: ${name}, variables: ${variables}`;
        }
        else {
            return `Match by function: ${matcher.name}`;
        }
    }
}
ApolloTestingBackend.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const APOLLO_TESTING_CACHE = new InjectionToken('apollo-angular/testing cache');
class ApolloTestingModule {
    /**
     * @param {?} apollo
     * @param {?} backend
     * @param {?=} cache
     */
    constructor(apollo, backend, cache) {
        apollo.create({
            link: new ApolloLink(operation => backend.handle(operation)),
            cache: cache ||
                new InMemoryCache({
                    addTypename: false,
                }),
        });
    }
}
ApolloTestingModule.decorators = [
    { type: NgModule, args: [{
                imports: [ApolloModule],
                providers: [
                    ApolloTestingBackend,
                    { provide: ApolloTestingController, useExisting: ApolloTestingBackend },
                ],
            },] }
];
/** @nocollapse */
ApolloTestingModule.ctorParameters = () => [
    { type: Apollo },
    { type: ApolloTestingBackend },
    { type: ApolloCache, decorators: [{ type: Optional }, { type: Inject, args: [APOLLO_TESTING_CACHE,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { ApolloTestingController, ApolloTestingModule, APOLLO_TESTING_CACHE, TestOperation, ApolloTestingBackend as Éµa };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmcuYXBvbGxvLnRlc3RpbmcuanMubWFwIiwic291cmNlcyI6WyJuZzovL2Fwb2xsby1hbmd1bGFyL3Rlc3RpbmcvY29udHJvbGxlci50cyIsIm5nOi8vYXBvbGxvLWFuZ3VsYXIvdGVzdGluZy9vcGVyYXRpb24udHMiLCJuZzovL2Fwb2xsby1hbmd1bGFyL3Rlc3RpbmcvYmFja2VuZC50cyIsIm5nOi8vYXBvbGxvLWFuZ3VsYXIvdGVzdGluZy9tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtPcGVyYXRpb259IGZyb20gJ2Fwb2xsby1saW5rJztcbmltcG9ydCB7RG9jdW1lbnROb2RlfSBmcm9tICdncmFwaHFsJztcblxuaW1wb3J0IHtUZXN0T3BlcmF0aW9ufSBmcm9tICcuL29wZXJhdGlvbic7XG5cbmV4cG9ydCB0eXBlIE1hdGNoT3BlcmF0aW9uRm4gPSAob3A6IE9wZXJhdGlvbikgPT4gYm9vbGVhbjtcbmV4cG9ydCB0eXBlIE1hdGNoT3BlcmF0aW9uID1cbiAgfCBzdHJpbmdcbiAgfCBEb2N1bWVudE5vZGVcbiAgfCBPcGVyYXRpb25cbiAgfCBNYXRjaE9wZXJhdGlvbkZuO1xuXG4vKipcbiAqIENvbnRyb2xsZXIgdG8gYmUgaW5qZWN0ZWQgaW50byB0ZXN0cywgdGhhdCBhbGxvd3MgZm9yIG1vY2tpbmcgYW5kIGZsdXNoaW5nXG4gKiBvZiBvcGVyYXRpb25zLlxuICpcbiAqXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBcG9sbG9UZXN0aW5nQ29udHJvbGxlciB7XG4gIC8qKlxuICAgKiBTZWFyY2ggZm9yIG9wZXJhdGlvbnMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gcGFyYW1ldGVyLCB3aXRob3V0IGFueSBleHBlY3RhdGlvbnMuXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgbWF0Y2gobWF0Y2g6IE1hdGNoT3BlcmF0aW9uKTogVGVzdE9wZXJhdGlvbltdO1xuXG4gIC8qKlxuICAgKiBFeHBlY3QgdGhhdCBhIHNpbmdsZSAgaGFzIGJlZW4gbWFkZSB3aGljaCBtYXRjaGVzIHRoZSBnaXZlbiBVUkwsIGFuZCByZXR1cm4gaXRzXG4gICAqIG1vY2suXG4gICAqXG4gICAqIElmIG5vIHN1Y2ggIGhhcyBiZWVuIG1hZGUsIG9yIG1vcmUgdGhhbiBvbmUgc3VjaCAgaGFzIGJlZW4gbWFkZSwgZmFpbCB3aXRoIGFuXG4gICAqIGVycm9yIG1lc3NhZ2UgaW5jbHVkaW5nIHRoZSBnaXZlbiAgZGVzY3JpcHRpb24sIGlmIGFueS5cbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBleHBlY3RPbmUoXG4gICAgb3BlcmF0aW9uTmFtZTogc3RyaW5nLFxuICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nLFxuICApOiBUZXN0T3BlcmF0aW9uO1xuXG4gIC8qKlxuICAgKiBFeHBlY3QgdGhhdCBhIHNpbmdsZSAgaGFzIGJlZW4gbWFkZSB3aGljaCBtYXRjaGVzIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLCBhbmQgcmV0dXJuXG4gICAqIGl0cyBtb2NrLlxuICAgKlxuICAgKiBJZiBubyBzdWNoICBoYXMgYmVlbiBtYWRlLCBvciBtb3JlIHRoYW4gb25lIHN1Y2ggIGhhcyBiZWVuIG1hZGUsIGZhaWwgd2l0aCBhblxuICAgKiBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZ2l2ZW4gIGRlc2NyaXB0aW9uLCBpZiBhbnkuXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgZXhwZWN0T25lKG9wOiBPcGVyYXRpb24sIGRlc2NyaXB0aW9uPzogc3RyaW5nKTogVGVzdE9wZXJhdGlvbjtcblxuICAvKipcbiAgICogRXhwZWN0IHRoYXQgYSBzaW5nbGUgIGhhcyBiZWVuIG1hZGUgd2hpY2ggbWF0Y2hlcyB0aGUgZ2l2ZW4gcHJlZGljYXRlIGZ1bmN0aW9uLCBhbmRcbiAgICogcmV0dXJuIGl0cyBtb2NrLlxuICAgKlxuICAgKiBJZiBubyBzdWNoICBoYXMgYmVlbiBtYWRlLCBvciBtb3JlIHRoYW4gb25lIHN1Y2ggIGhhcyBiZWVuIG1hZGUsIGZhaWwgd2l0aCBhblxuICAgKiBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZ2l2ZW4gIGRlc2NyaXB0aW9uLCBpZiBhbnkuXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgZXhwZWN0T25lKFxuICAgIG1hdGNoRm46IE1hdGNoT3BlcmF0aW9uRm4sXG4gICAgZGVzY3JpcHRpb24/OiBzdHJpbmcsXG4gICk6IFRlc3RPcGVyYXRpb247XG5cbiAgLyoqXG4gICAqIEV4cGVjdCB0aGF0IGEgc2luZ2xlICBoYXMgYmVlbiBtYWRlIHdoaWNoIG1hdGNoZXMgdGhlIGdpdmVuIGNvbmRpdGlvbiwgYW5kIHJldHVyblxuICAgKiBpdHMgbW9jay5cbiAgICpcbiAgICogSWYgbm8gc3VjaCAgaGFzIGJlZW4gbWFkZSwgb3IgbW9yZSB0aGFuIG9uZSBzdWNoICBoYXMgYmVlbiBtYWRlLCBmYWlsIHdpdGggYW5cbiAgICogZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGdpdmVuICBkZXNjcmlwdGlvbiwgaWYgYW55LlxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IGV4cGVjdE9uZShcbiAgICBtYXRjaDogTWF0Y2hPcGVyYXRpb24sXG4gICAgZGVzY3JpcHRpb24/OiBzdHJpbmcsXG4gICk6IFRlc3RPcGVyYXRpb247XG5cbiAgLyoqXG4gICAqIEV4cGVjdCB0aGF0IG5vIG9wZXJhdGlvbnMgaGF2ZSBiZWVuIG1hZGUgd2hpY2ggbWF0Y2ggdGhlIGdpdmVuIFVSTC5cbiAgICpcbiAgICogSWYgYSBtYXRjaGluZyAgaGFzIGJlZW4gbWFkZSwgZmFpbCB3aXRoIGFuIGVycm9yIG1lc3NhZ2UgaW5jbHVkaW5nIHRoZSBnaXZlblxuICAgKiBkZXNjcmlwdGlvbiwgaWYgYW55LlxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IGV4cGVjdE5vbmUob3BlcmF0aW9uTmFtZTogc3RyaW5nLCBkZXNjcmlwdGlvbj86IHN0cmluZyk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEV4cGVjdCB0aGF0IG5vIG9wZXJhdGlvbnMgaGF2ZSBiZWVuIG1hZGUgd2hpY2ggbWF0Y2ggdGhlIGdpdmVuIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIElmIGEgbWF0Y2hpbmcgIGhhcyBiZWVuIG1hZGUsIGZhaWwgd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZ2l2ZW5cbiAgICogZGVzY3JpcHRpb24sIGlmIGFueS5cbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBleHBlY3ROb25lKG9wOiBPcGVyYXRpb24sIGRlc2NyaXB0aW9uPzogc3RyaW5nKTogdm9pZDtcblxuICAvKipcbiAgICogRXhwZWN0IHRoYXQgbm8gb3BlcmF0aW9ucyBoYXZlIGJlZW4gbWFkZSB3aGljaCBtYXRjaCB0aGUgZ2l2ZW4gcHJlZGljYXRlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBJZiBhIG1hdGNoaW5nICBoYXMgYmVlbiBtYWRlLCBmYWlsIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGdpdmVuXG4gICAqIGRlc2NyaXB0aW9uLCBpZiBhbnkuXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgZXhwZWN0Tm9uZShcbiAgICBtYXRjaEZuOiBNYXRjaE9wZXJhdGlvbkZuLFxuICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nLFxuICApOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBFeHBlY3QgdGhhdCBubyBvcGVyYXRpb25zIGhhdmUgYmVlbiBtYWRlIHdoaWNoIG1hdGNoIHRoZSBnaXZlbiBjb25kaXRpb24uXG4gICAqXG4gICAqIElmIGEgbWF0Y2hpbmcgIGhhcyBiZWVuIG1hZGUsIGZhaWwgd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZ2l2ZW5cbiAgICogZGVzY3JpcHRpb24sIGlmIGFueS5cbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBleHBlY3ROb25lKG1hdGNoOiBNYXRjaE9wZXJhdGlvbiwgZGVzY3JpcHRpb24/OiBzdHJpbmcpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBWZXJpZnkgdGhhdCBubyB1bm1hdGNoZWQgb3BlcmF0aW9ucyBhcmUgb3V0c3RhbmRpbmcuXG4gICAqXG4gICAqIElmIGFueSBvcGVyYXRpb25zIGFyZSBvdXRzdGFuZGluZywgZmFpbCB3aXRoIGFuIGVycm9yIG1lc3NhZ2UgaW5kaWNhdGluZyB3aGljaCBvcGVyYXRpb25zIHdlcmUgbm90XG4gICAqIGhhbmRsZWQuXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgdmVyaWZ5KCk6IHZvaWQ7XG59XG4iLCJpbXBvcnQge0Fwb2xsb0Vycm9yfSBmcm9tICdhcG9sbG8tY2xpZW50JztcbmltcG9ydCB7T3BlcmF0aW9uLCBGZXRjaFJlc3VsdH0gZnJvbSAnYXBvbGxvLWxpbmsnO1xuaW1wb3J0IHtHcmFwaFFMRXJyb3IsIEV4ZWN1dGlvblJlc3VsdH0gZnJvbSAnZ3JhcGhxbCc7XG5pbXBvcnQge09ic2VydmVyfSBmcm9tICdyeGpzJztcblxuY29uc3QgaXNBcG9sbG9FcnJvciA9IChlcnI6IGFueSk6IGVyciBpcyBBcG9sbG9FcnJvciA9PlxuICBlcnIgJiYgZXJyLmhhc093blByb3BlcnR5KCdncmFwaFFMRXJyb3JzJyk7XG5cbmV4cG9ydCBjbGFzcyBUZXN0T3BlcmF0aW9uIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIG9wZXJhdGlvbjogT3BlcmF0aW9uLFxuICAgIHByaXZhdGUgb2JzZXJ2ZXI6IE9ic2VydmVyPEZldGNoUmVzdWx0PixcbiAgKSB7fVxuXG4gIHB1YmxpYyBmbHVzaChyZXN1bHQ6IEV4ZWN1dGlvblJlc3VsdCB8IEFwb2xsb0Vycm9yKTogdm9pZCB7XG4gICAgaWYgKGlzQXBvbGxvRXJyb3IocmVzdWx0KSkge1xuICAgICAgdGhpcy5vYnNlcnZlci5lcnJvcihyZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9ic2VydmVyLm5leHQocmVzdWx0IGFzIEZldGNoUmVzdWx0KTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgbmV0d29ya0Vycm9yKGVycm9yOiBFcnJvcik6IHZvaWQge1xuICAgIGNvbnN0IGFwb2xsb0Vycm9yID0gbmV3IEFwb2xsb0Vycm9yKHtcbiAgICAgIG5ldHdvcmtFcnJvcjogZXJyb3IsXG4gICAgfSk7XG5cbiAgICB0aGlzLmZsdXNoKGFwb2xsb0Vycm9yKTtcbiAgfVxuXG4gIHB1YmxpYyBncmFwaHFsRXJyb3JzKGVycm9yczogR3JhcGhRTEVycm9yW10pOiB2b2lkIHtcbiAgICB0aGlzLmZsdXNoKHtcbiAgICAgIGVycm9ycyxcbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7T2JzZXJ2ZXJ9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtcbiAgT3BlcmF0aW9uLFxuICBGZXRjaFJlc3VsdCxcbiAgT2JzZXJ2YWJsZSBhcyBMaW5rT2JzZXJ2YWJsZSxcbn0gZnJvbSAnYXBvbGxvLWxpbmsnO1xuaW1wb3J0IHtEb2N1bWVudE5vZGV9IGZyb20gJ2dyYXBocWwnO1xuaW1wb3J0IHtwcmludH0gZnJvbSAnZ3JhcGhxbC9sYW5ndWFnZS9wcmludGVyJztcblxuaW1wb3J0IHtBcG9sbG9UZXN0aW5nQ29udHJvbGxlciwgTWF0Y2hPcGVyYXRpb259IGZyb20gJy4vY29udHJvbGxlcic7XG5pbXBvcnQge1Rlc3RPcGVyYXRpb259IGZyb20gJy4vb3BlcmF0aW9uJztcblxuLyoqXG4gKiBBIHRlc3RpbmcgYmFja2VuZCBmb3IgYEFwb2xsb2AuXG4gKlxuICogYEFwb2xsb1Rlc3RpbmdCYWNrZW5kYCB3b3JrcyBieSBrZWVwaW5nIGEgbGlzdCBvZiBhbGwgb3BlbiBvcGVyYXRpb25zLlxuICogQXMgb3BlcmF0aW9ucyBjb21lIGluLCB0aGV5J3JlIGFkZGVkIHRvIHRoZSBsaXN0LiBVc2VycyBjYW4gYXNzZXJ0IHRoYXQgc3BlY2lmaWNcbiAqIG9wZXJhdGlvbnMgd2VyZSBtYWRlIGFuZCB0aGVuIGZsdXNoIHRoZW0uIEluIHRoZSBlbmQsIGEgdmVyaWZ5KCkgbWV0aG9kIGFzc2VydHNcbiAqIHRoYXQgbm8gdW5leHBlY3RlZCBvcGVyYXRpb25zIHdlcmUgbWFkZS5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEFwb2xsb1Rlc3RpbmdCYWNrZW5kIGltcGxlbWVudHMgQXBvbGxvVGVzdGluZ0NvbnRyb2xsZXIge1xuICAvKipcbiAgICogTGlzdCBvZiBwZW5kaW5nIG9wZXJhdGlvbnMgd2hpY2ggaGF2ZSBub3QgeWV0IGJlZW4gZXhwZWN0ZWQuXG4gICAqL1xuICBwcml2YXRlIG9wZW46IFRlc3RPcGVyYXRpb25bXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYW4gaW5jb21pbmcgb3BlcmF0aW9uIGJ5IHF1ZXVlaW5nIGl0IGluIHRoZSBsaXN0IG9mIG9wZW4gb3BlcmF0aW9ucy5cbiAgICovXG4gIHB1YmxpYyBoYW5kbGUob3A6IE9wZXJhdGlvbik6IExpbmtPYnNlcnZhYmxlPEZldGNoUmVzdWx0PiB7XG4gICAgcmV0dXJuIG5ldyBMaW5rT2JzZXJ2YWJsZSgob2JzZXJ2ZXI6IE9ic2VydmVyPGFueT4pID0+IHtcbiAgICAgIGNvbnN0IHRlc3RPcCA9IG5ldyBUZXN0T3BlcmF0aW9uKG9wLCBvYnNlcnZlcik7XG4gICAgICB0aGlzLm9wZW4ucHVzaCh0ZXN0T3ApO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byBzZWFyY2ggZm9yIG9wZXJhdGlvbnMgaW4gdGhlIGxpc3Qgb2Ygb3BlbiBvcGVyYXRpb25zLlxuICAgKi9cbiAgcHJpdmF0ZSBfbWF0Y2gobWF0Y2g6IE1hdGNoT3BlcmF0aW9uKTogVGVzdE9wZXJhdGlvbltdIHtcbiAgICBpZiAodHlwZW9mIG1hdGNoID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXMub3Blbi5maWx0ZXIoXG4gICAgICAgIHRlc3RPcCA9PiB0ZXN0T3Aub3BlcmF0aW9uLm9wZXJhdGlvbk5hbWUgPT09IG1hdGNoLFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMub3Blbi5maWx0ZXIodGVzdE9wID0+IG1hdGNoKHRlc3RPcC5vcGVyYXRpb24pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuaXNEb2N1bWVudE5vZGUobWF0Y2gpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZW4uZmlsdGVyKFxuICAgICAgICAgIHRlc3RPcCA9PiBwcmludCh0ZXN0T3Aub3BlcmF0aW9uLnF1ZXJ5KSA9PT0gcHJpbnQobWF0Y2gpLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5vcGVuLmZpbHRlcih0ZXN0T3AgPT4gdGhpcy5tYXRjaE9wKG1hdGNoLCB0ZXN0T3ApKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG1hdGNoT3AobWF0Y2g6IE9wZXJhdGlvbiwgdGVzdE9wOiBUZXN0T3BlcmF0aW9uKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdmFyaWFibGVzID0gSlNPTi5zdHJpbmdpZnkobWF0Y2gudmFyaWFibGVzKTtcbiAgICBjb25zdCBleHRlbnNpb25zID0gSlNPTi5zdHJpbmdpZnkobWF0Y2guZXh0ZW5zaW9ucyk7XG5cbiAgICBjb25zdCBzYW1lTmFtZSA9IHRoaXMuY29tcGFyZShcbiAgICAgIG1hdGNoLm9wZXJhdGlvbk5hbWUsXG4gICAgICB0ZXN0T3Aub3BlcmF0aW9uLm9wZXJhdGlvbk5hbWUsXG4gICAgKTtcbiAgICBjb25zdCBzYW1lVmFyaWFibGVzID0gdGhpcy5jb21wYXJlKHZhcmlhYmxlcywgdGVzdE9wLm9wZXJhdGlvbi52YXJpYWJsZXMpO1xuXG4gICAgY29uc3Qgc2FtZVF1ZXJ5ID0gcHJpbnQodGVzdE9wLm9wZXJhdGlvbi5xdWVyeSkgPT09IHByaW50KG1hdGNoLnF1ZXJ5KTtcblxuICAgIGNvbnN0IHNhbWVFeHRlbnNpb25zID0gdGhpcy5jb21wYXJlKFxuICAgICAgZXh0ZW5zaW9ucyxcbiAgICAgIHRlc3RPcC5vcGVyYXRpb24uZXh0ZW5zaW9ucyxcbiAgICApO1xuXG4gICAgcmV0dXJuIHNhbWVOYW1lICYmIHNhbWVWYXJpYWJsZXMgJiYgc2FtZVF1ZXJ5ICYmIHNhbWVFeHRlbnNpb25zO1xuICB9XG5cbiAgcHJpdmF0ZSBjb21wYXJlKGV4cGVjdGVkPzogc3RyaW5nLCB2YWx1ZT86IE9iamVjdCB8IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHByZXBhcmUgPSAodmFsOiBhbnkpID0+XG4gICAgICB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/IHZhbCA6IEpTT04uc3RyaW5naWZ5KHZhbCk7XG4gICAgY29uc3QgcmVjZWl2ZWQgPSBwcmVwYXJlKHZhbHVlKTtcblxuICAgIHJldHVybiAhZXhwZWN0ZWQgfHwgcmVjZWl2ZWQgPT09IGV4cGVjdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaCBmb3Igb3BlcmF0aW9ucyBpbiB0aGUgbGlzdCBvZiBvcGVuIG9wZXJhdGlvbnMsIGFuZCByZXR1cm4gYWxsIHRoYXQgbWF0Y2hcbiAgICogd2l0aG91dCBhc3NlcnRpbmcgYW55dGhpbmcgYWJvdXQgdGhlIG51bWJlciBvZiBtYXRjaGVzLlxuICAgKi9cbiAgcHVibGljIG1hdGNoKG1hdGNoOiBNYXRjaE9wZXJhdGlvbik6IFRlc3RPcGVyYXRpb25bXSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IHRoaXMuX21hdGNoKG1hdGNoKTtcblxuICAgIHJlc3VsdHMuZm9yRWFjaChyZXN1bHQgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm9wZW4uaW5kZXhPZihyZXN1bHQpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLm9wZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBlY3QgdGhhdCBhIHNpbmdsZSBvdXRzdGFuZGluZyByZXF1ZXN0IG1hdGNoZXMgdGhlIGdpdmVuIG1hdGNoZXIsIGFuZCByZXR1cm5cbiAgICogaXQuXG4gICAqXG4gICAqIG9wZXJhdGlvbnMgcmV0dXJuZWQgdGhyb3VnaCB0aGlzIEFQSSB3aWxsIG5vIGxvbmdlciBiZSBpbiB0aGUgbGlzdCBvZiBvcGVuIG9wZXJhdGlvbnMsXG4gICAqIGFuZCB0aHVzIHdpbGwgbm90IG1hdGNoIHR3aWNlLlxuICAgKi9cbiAgcHVibGljIGV4cGVjdE9uZShtYXRjaDogTWF0Y2hPcGVyYXRpb24sIGRlc2NyaXB0aW9uPzogc3RyaW5nKTogVGVzdE9wZXJhdGlvbiB7XG4gICAgZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbiB8fCB0aGlzLmRlc2NyaXB0aW9uRnJvbU1hdGNoZXIobWF0Y2gpO1xuICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLm1hdGNoKG1hdGNoKTtcbiAgICBpZiAobWF0Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBFeHBlY3RlZCBvbmUgbWF0Y2hpbmcgb3BlcmF0aW9uIGZvciBjcml0ZXJpYSBcIiR7ZGVzY3JpcHRpb259XCIsIGZvdW5kICR7XG4gICAgICAgICAgbWF0Y2hlcy5sZW5ndGhcbiAgICAgICAgfSBvcGVyYXRpb25zLmAsXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEV4cGVjdGVkIG9uZSBtYXRjaGluZyBvcGVyYXRpb24gZm9yIGNyaXRlcmlhIFwiJHtkZXNjcmlwdGlvbn1cIiwgZm91bmQgbm9uZS5gLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXNbMF07XG4gIH1cblxuICAvKipcbiAgICogRXhwZWN0IHRoYXQgbm8gb3V0c3RhbmRpbmcgb3BlcmF0aW9ucyBtYXRjaCB0aGUgZ2l2ZW4gbWF0Y2hlciwgYW5kIHRocm93IGFuIGVycm9yXG4gICAqIGlmIGFueSBkby5cbiAgICovXG4gIHB1YmxpYyBleHBlY3ROb25lKG1hdGNoOiBNYXRjaE9wZXJhdGlvbiwgZGVzY3JpcHRpb24/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uIHx8IHRoaXMuZGVzY3JpcHRpb25Gcm9tTWF0Y2hlcihtYXRjaCk7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMubWF0Y2gobWF0Y2gpO1xuICAgIGlmIChtYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEV4cGVjdGVkIHplcm8gbWF0Y2hpbmcgb3BlcmF0aW9ucyBmb3IgY3JpdGVyaWEgXCIke2Rlc2NyaXB0aW9ufVwiLCBmb3VuZCAke1xuICAgICAgICAgIG1hdGNoZXMubGVuZ3RoXG4gICAgICAgIH0uYCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHRoYXQgdGhlcmUgYXJlIG5vIG91dHN0YW5kaW5nIG9wZXJhdGlvbnMuXG4gICAqL1xuICBwdWJsaWMgdmVyaWZ5KCk6IHZvaWQge1xuICAgIGNvbnN0IG9wZW4gPSB0aGlzLm9wZW47XG5cbiAgICBpZiAob3Blbi5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBTaG93IHRoZSBtZXRob2RzIGFuZCBVUkxzIG9mIG9wZW4gb3BlcmF0aW9ucyBpbiB0aGUgZXJyb3IsIGZvciBjb252ZW5pZW5jZS5cbiAgICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBvcGVuXG4gICAgICAgIC5tYXAodGVzdE9wID0+IHRlc3RPcC5vcGVyYXRpb24ub3BlcmF0aW9uTmFtZSlcbiAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBFeHBlY3RlZCBubyBvcGVuIG9wZXJhdGlvbnMsIGZvdW5kICR7b3Blbi5sZW5ndGh9OiAke29wZXJhdGlvbnN9YCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBpc0RvY3VtZW50Tm9kZShcbiAgICBkb2NPck9wOiBEb2N1bWVudE5vZGUgfCBPcGVyYXRpb24sXG4gICk6IGRvY09yT3AgaXMgRG9jdW1lbnROb2RlIHtcbiAgICByZXR1cm4gIShkb2NPck9wIGFzIE9wZXJhdGlvbikub3BlcmF0aW9uTmFtZTtcbiAgfVxuXG4gIHByaXZhdGUgZGVzY3JpcHRpb25Gcm9tTWF0Y2hlcihtYXRjaGVyOiBNYXRjaE9wZXJhdGlvbik6IHN0cmluZyB7XG4gICAgaWYgKHR5cGVvZiBtYXRjaGVyID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGBNYXRjaCBvcGVyYXRpb25OYW1lOiAke21hdGNoZXJ9YDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXRjaGVyID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHRoaXMuaXNEb2N1bWVudE5vZGUobWF0Y2hlcikpIHtcbiAgICAgICAgcmV0dXJuIGBNYXRjaCBEb2N1bWVudE5vZGVgO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuYW1lID0gbWF0Y2hlci5vcGVyYXRpb25OYW1lIHx8ICcoYW55KSc7XG4gICAgICBjb25zdCB2YXJpYWJsZXMgPSBKU09OLnN0cmluZ2lmeShtYXRjaGVyLnZhcmlhYmxlcykgfHwgJyhhbnkpJztcblxuICAgICAgcmV0dXJuIGBNYXRjaCBvcGVyYXRpb246ICR7bmFtZX0sIHZhcmlhYmxlczogJHt2YXJpYWJsZXN9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGBNYXRjaCBieSBmdW5jdGlvbjogJHttYXRjaGVyLm5hbWV9YDtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7QXBvbGxvTW9kdWxlLCBBcG9sbG99IGZyb20gJ2Fwb2xsby1hbmd1bGFyJztcbmltcG9ydCB7QXBvbGxvTGlua30gZnJvbSAnYXBvbGxvLWxpbmsnO1xuaW1wb3J0IHtJbk1lbW9yeUNhY2hlfSBmcm9tICdhcG9sbG8tY2FjaGUtaW5tZW1vcnknO1xuaW1wb3J0IHtBcG9sbG9DYWNoZX0gZnJvbSAnYXBvbGxvLWNhY2hlJztcbmltcG9ydCB7TmdNb2R1bGUsIEluamVjdGlvblRva2VuLCBJbmplY3QsIE9wdGlvbmFsfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHtBcG9sbG9UZXN0aW5nQ29udHJvbGxlcn0gZnJvbSAnLi9jb250cm9sbGVyJztcbmltcG9ydCB7QXBvbGxvVGVzdGluZ0JhY2tlbmR9IGZyb20gJy4vYmFja2VuZCc7XG5cbmV4cG9ydCBjb25zdCBBUE9MTE9fVEVTVElOR19DQUNIRSA9IG5ldyBJbmplY3Rpb25Ub2tlbjxBcG9sbG9DYWNoZTxhbnk+PihcbiAgJ2Fwb2xsby1hbmd1bGFyL3Rlc3RpbmcgY2FjaGUnLFxuKTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0Fwb2xsb01vZHVsZV0sXG4gIHByb3ZpZGVyczogW1xuICAgIEFwb2xsb1Rlc3RpbmdCYWNrZW5kLFxuICAgIHtwcm92aWRlOiBBcG9sbG9UZXN0aW5nQ29udHJvbGxlciwgdXNlRXhpc3Rpbmc6IEFwb2xsb1Rlc3RpbmdCYWNrZW5kfSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgQXBvbGxvVGVzdGluZ01vZHVsZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIGFwb2xsbzogQXBvbGxvLFxuICAgIGJhY2tlbmQ6IEFwb2xsb1Rlc3RpbmdCYWNrZW5kLFxuICAgIEBPcHRpb25hbCgpXG4gICAgQEluamVjdChBUE9MTE9fVEVTVElOR19DQUNIRSlcbiAgICBjYWNoZT86IEFwb2xsb0NhY2hlPGFueT4sXG4gICkge1xuICAgIGFwb2xsby5jcmVhdGUoe1xuICAgICAgbGluazogbmV3IEFwb2xsb0xpbmsob3BlcmF0aW9uID0+IGJhY2tlbmQuaGFuZGxlKG9wZXJhdGlvbikpLFxuICAgICAgY2FjaGU6XG4gICAgICAgIGNhY2hlIHx8XG4gICAgICAgIG5ldyBJbk1lbW9yeUNhY2hlKHtcbiAgICAgICAgICBhZGRUeXBlbmFtZTogZmFsc2UsXG4gICAgICAgIH0pLFxuICAgIH0pO1xuICB9XG59XG4iXSwibmFtZXMiOlsiTGlua09ic2VydmFibGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7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