/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { Observable as LinkObservable, } from 'apollo-link';
import { print } from 'graphql/language/printer';
import { TestOperation } from './operation';
/**
 * A testing backend for `Apollo`.
 *
 * `ApolloTestingBackend` works by keeping a list of all open operations.
 * As operations come in, they're added to the list. Users can assert that specific
 * operations were made and then flush them. In the end, a verify() method asserts
 * that no unexpected operations were made.
 */
export class ApolloTestingBackend {
    constructor() {
        /**
         * List of pending operations which have not yet been expected.
         */
        this.open = [];
    }
    /**
     * Handle an incoming operation by queueing it in the list of open operations.
     * @param {?} op
     * @return {?}
     */
    handle(op) {
        return new LinkObservable((observer) => {
            /** @type {?} */
            const testOp = new TestOperation(op, observer);
            this.open.push(testOp);
        });
    }
    /**
     * Helper function to search for operations in the list of open operations.
     * @param {?} match
     * @return {?}
     */
    _match(match) {
        if (typeof match === 'string') {
            return this.open.filter(testOp => testOp.operation.operationName === match);
        }
        else if (typeof match === 'function') {
            return this.open.filter(testOp => match(testOp.operation));
        }
        else {
            if (this.isDocumentNode(match)) {
                return this.open.filter(testOp => print(testOp.operation.query) === print(match));
            }
            return this.open.filter(testOp => this.matchOp(match, testOp));
        }
    }
    /**
     * @param {?} match
     * @param {?} testOp
     * @return {?}
     */
    matchOp(match, testOp) {
        /** @type {?} */
        const variables = JSON.stringify(match.variables);
        /** @type {?} */
        const extensions = JSON.stringify(match.extensions);
        /** @type {?} */
        const sameName = this.compare(match.operationName, testOp.operation.operationName);
        /** @type {?} */
        const sameVariables = this.compare(variables, testOp.operation.variables);
        /** @type {?} */
        const sameQuery = print(testOp.operation.query) === print(match.query);
        /** @type {?} */
        const sameExtensions = this.compare(extensions, testOp.operation.extensions);
        return sameName && sameVariables && sameQuery && sameExtensions;
    }
    /**
     * @param {?=} expected
     * @param {?=} value
     * @return {?}
     */
    compare(expected, value) {
        /** @type {?} */
        const prepare = (val) => typeof val === 'string' ? val : JSON.stringify(val);
        /** @type {?} */
        const received = prepare(value);
        return !expected || received === expected;
    }
    /**
     * Search for operations in the list of open operations, and return all that match
     * without asserting anything about the number of matches.
     * @param {?} match
     * @return {?}
     */
    match(match) {
        /** @type {?} */
        const results = this._match(match);
        results.forEach(result => {
            /** @type {?} */
            const index = this.open.indexOf(result);
            if (index !== -1) {
                this.open.splice(index, 1);
            }
        });
        return results;
    }
    /**
     * Expect that a single outstanding request matches the given matcher, and return
     * it.
     *
     * operations returned through this API will no longer be in the list of open operations,
     * and thus will not match twice.
     * @param {?} match
     * @param {?=} description
     * @return {?}
     */
    expectOne(match, description) {
        description = description || this.descriptionFromMatcher(match);
        /** @type {?} */
        const matches = this.match(match);
        if (matches.length > 1) {
            throw new Error(`Expected one matching operation for criteria "${description}", found ${matches.length} operations.`);
        }
        if (matches.length === 0) {
            throw new Error(`Expected one matching operation for criteria "${description}", found none.`);
        }
        return matches[0];
    }
    /**
     * Expect that no outstanding operations match the given matcher, and throw an error
     * if any do.
     * @param {?} match
     * @param {?=} description
     * @return {?}
     */
    expectNone(match, description) {
        description = description || this.descriptionFromMatcher(match);
        /** @type {?} */
        const matches = this.match(match);
        if (matches.length > 0) {
            throw new Error(`Expected zero matching operations for criteria "${description}", found ${matches.length}.`);
        }
    }
    /**
     * Validate that there are no outstanding operations.
     * @return {?}
     */
    verify() {
        /** @type {?} */
        const open = this.open;
        if (open.length > 0) {
            // Show the methods and URLs of open operations in the error, for convenience.
            /** @type {?} */
            const operations = open
                .map(testOp => testOp.operation.operationName)
                .join(', ');
            throw new Error(`Expected no open operations, found ${open.length}: ${operations}`);
        }
    }
    /**
     * @param {?} docOrOp
     * @return {?}
     */
    isDocumentNode(docOrOp) {
        return !((/** @type {?} */ (docOrOp))).operationName;
    }
    /**
     * @param {?} matcher
     * @return {?}
     */
    descriptionFromMatcher(matcher) {
        if (typeof matcher === 'string') {
            return `Match operationName: ${matcher}`;
        }
        else if (typeof matcher === 'object') {
            if (this.isDocumentNode(matcher)) {
                return `Match DocumentNode`;
            }
            /** @type {?} */
            const name = matcher.operationName || '(any)';
            /** @type {?} */
            const variables = JSON.stringify(matcher.variables) || '(any)';
            return `Match operation: ${name}, variables: ${variables}`;
        }
        else {
            return `Match by function: ${matcher.name}`;
        }
    }
}
ApolloTestingBackend.decorators = [
    { type: Injectable }
];
if (false) {
    /**
     * List of pending operations which have not yet been expected.
     * @type {?}
     */
    ApolloTestingBackend.prototype.open;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja2VuZC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2Fwb2xsby1hbmd1bGFyL3Rlc3RpbmcvIiwic291cmNlcyI6WyJiYWNrZW5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBRXpDLE9BQU8sRUFHTCxVQUFVLElBQUksY0FBYyxHQUM3QixNQUFNLGFBQWEsQ0FBQztBQUVyQixPQUFPLEVBQUMsS0FBSyxFQUFDLE1BQU0sMEJBQTBCLENBQUM7QUFHL0MsT0FBTyxFQUFDLGFBQWEsRUFBQyxNQUFNLGFBQWEsQ0FBQzs7Ozs7Ozs7O0FBVzFDLE1BQU0sT0FBTyxvQkFBb0I7SUFEakM7Ozs7UUFLVSxTQUFJLEdBQW9CLEVBQUUsQ0FBQztJQTZKckMsQ0FBQzs7Ozs7O0lBeEpRLE1BQU0sQ0FBQyxFQUFhO1FBQ3pCLE9BQU8sSUFBSSxjQUFjLENBQUMsQ0FBQyxRQUF1QixFQUFFLEVBQUU7O2tCQUM5QyxNQUFNLEdBQUcsSUFBSSxhQUFhLENBQUMsRUFBRSxFQUFFLFFBQVEsQ0FBQztZQUM5QyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN6QixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7Ozs7OztJQUtPLE1BQU0sQ0FBQyxLQUFxQjtRQUNsQyxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRTtZQUM3QixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUNyQixNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsYUFBYSxLQUFLLEtBQUssQ0FDbkQsQ0FBQztTQUNIO2FBQU0sSUFBSSxPQUFPLEtBQUssS0FBSyxVQUFVLEVBQUU7WUFDdEMsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FB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Q0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ2hDLE9BQU8sb0JBQW9CLENBQUM7YUFDN0I7O2tCQUVLLElBQUksR0FBRyxPQUFPLENBQUMsYUFBYSxJQUFJLE9BQU87O2tCQUN2QyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLElBQUksT0FBTztZQUU5RCxPQUFPLG9CQUFvQixJQUFJLGdCQUFnQixTQUFTLEVBQUUsQ0FBQztTQUM1RDthQUFNO1lBQ0wsT0FBTyxzQkFBc0IsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDO1NBQzdDO0lBQ0gsQ0FBQzs7O1lBaktGLFVBQVU7Ozs7Ozs7SUFLVCxvQ0FBbUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0luamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtPYnNlcnZlcn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1xuICBPcGVyYXRpb24sXG4gIEZldGNoUmVzdWx0LFxuICBPYnNlcnZhYmxlIGFzIExpbmtPYnNlcnZhYmxlLFxufSBmcm9tICdhcG9sbG8tbGluayc7XG5pbXBvcnQge0RvY3VtZW50Tm9kZX0gZnJvbSAnZ3JhcGhxbCc7XG5pbXBvcnQge3ByaW50fSBmcm9tICdncmFwaHFsL2xhbmd1YWdlL3ByaW50ZXInO1xuXG5pbXBvcnQge0Fwb2xsb1Rlc3RpbmdDb250cm9sbGVyLCBNYXRjaE9wZXJhdGlvbn0gZnJvbSAnLi9jb250cm9sbGVyJztcbmltcG9ydCB7VGVzdE9wZXJhdGlvbn0gZnJvbSAnLi9vcGVyYXRpb24nO1xuXG4vKipcbiAqIEEgdGVzdGluZyBiYWNrZW5kIGZvciBgQXBvbGxvYC5cbiAqXG4gKiBgQXBvbGxvVGVzdGluZ0JhY2tlbmRgIHdvcmtzIGJ5IGtlZXBpbmcgYSBsaXN0IG9mIGFsbCBvcGVuIG9wZXJhdGlvbnMuXG4gKiBBcyBvcGVyYXRpb25zIGNvbWUgaW4sIHRoZXkncmUgYWRkZWQgdG8gdGhlIGxpc3QuIFVzZXJzIGNhbiBhc3NlcnQgdGhhdCBzcGVjaWZpY1xuICogb3BlcmF0aW9ucyB3ZXJlIG1hZGUgYW5kIHRoZW4gZmx1c2ggdGhlbS4gSW4gdGhlIGVuZCwgYSB2ZXJpZnkoKSBtZXRob2QgYXNzZXJ0c1xuICogdGhhdCBubyB1bmV4cGVjdGVkIG9wZXJhdGlvbnMgd2VyZSBtYWRlLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQXBvbGxvVGVzdGluZ0JhY2tlbmQgaW1wbGVtZW50cyBBcG9sbG9UZXN0aW5nQ29udHJvbGxlciB7XG4gIC8qKlxuICAgKiBMaXN0IG9mIHBlbmRpbmcgb3BlcmF0aW9ucyB3aGljaCBoYXZlIG5vdCB5ZXQgYmVlbiBleHBlY3RlZC5cbiAgICovXG4gIHByaXZhdGUgb3BlbjogVGVzdE9wZXJhdGlvbltdID0gW107XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhbiBpbmNvbWluZyBvcGVyYXRpb24gYnkgcXVldWVpbmcgaXQgaW4gdGhlIGxpc3Qgb2Ygb3BlbiBvcGVyYXRpb25zLlxuICAgKi9cbiAgcHVibGljIGhhbmRsZShvcDogT3BlcmF0aW9uKTogTGlua09ic2VydmFibGU8RmV0Y2hSZXN1bHQ+IHtcbiAgICByZXR1cm4gbmV3IExpbmtPYnNlcnZhYmxlKChvYnNlcnZlcjogT2JzZXJ2ZXI8YW55PikgPT4ge1xuICAgICAgY29uc3QgdGVzdE9wID0gbmV3IFRlc3RPcGVyYXRpb24ob3AsIG9ic2VydmVyKTtcbiAgICAgIHRoaXMub3Blbi5wdXNoKHRlc3RPcCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIHNlYXJjaCBmb3Igb3BlcmF0aW9ucyBpbiB0aGUgbGlzdCBvZiBvcGVuIG9wZXJhdGlvbnMuXG4gICAqL1xuICBwcml2YXRlIF9tYXRjaChtYXRjaDogTWF0Y2hPcGVyYXRpb24pOiBUZXN0T3BlcmF0aW9uW10ge1xuICAgIGlmICh0eXBlb2YgbWF0Y2ggPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcGVuLmZpbHRlcihcbiAgICAgICAgdGVzdE9wID0+IHRlc3RPcC5vcGVyYXRpb24ub3BlcmF0aW9uTmFtZSA9PT0gbWF0Y2gsXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcGVuLmZpbHRlcih0ZXN0T3AgPT4gbWF0Y2godGVzdE9wLm9wZXJhdGlvbikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5pc0RvY3VtZW50Tm9kZShtYXRjaCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3Blbi5maWx0ZXIoXG4gICAgICAgICAgdGVzdE9wID0+IHByaW50KHRlc3RPcC5vcGVyYXRpb24ucXVlcnkpID09PSBwcmludChtYXRjaCksXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLm9wZW4uZmlsdGVyKHRlc3RPcCA9PiB0aGlzLm1hdGNoT3AobWF0Y2gsIHRlc3RPcCkpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgbWF0Y2hPcChtYXRjaDogT3BlcmF0aW9uLCB0ZXN0T3A6IFRlc3RPcGVyYXRpb24pOiBib29sZWFuIHtcbiAgICBjb25zdCB2YXJpYWJsZXMgPSBKU09OLnN0cmluZ2lmeShtYXRjaC52YXJpYWJsZXMpO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBKU09OLnN0cmluZ2lmeShtYXRjaC5leHRlbnNpb25zKTtcblxuICAgIGNvbnN0IHNhbWVOYW1lID0gdGhpcy5jb21wYXJlKFxuICAgICAgbWF0Y2gub3BlcmF0aW9uTmFtZSxcbiAgICAgIHRlc3RPcC5vcGVyYXRpb24ub3BlcmF0aW9uTmFtZSxcbiAgICApO1xuICAgIGNvbnN0IHNhbWVWYXJpYWJsZXMgPSB0aGlzLmNvbXBhcmUodmFyaWFibGVzLCB0ZXN0T3Aub3BlcmF0aW9uLnZhcmlhYmxlcyk7XG5cbiAgICBjb25zdCBzYW1lUXVlcnkgPSBwcmludCh0ZXN0T3Aub3BlcmF0aW9uLnF1ZXJ5KSA9PT0gcHJpbnQobWF0Y2gucXVlcnkpO1xuXG4gICAgY29uc3Qgc2FtZUV4dGVuc2lvbnMgPSB0aGlzLmNvbXBhcmUoXG4gICAgICBleHRlbnNpb25zLFxuICAgICAgdGVzdE9wLm9wZXJhdGlvbi5leHRlbnNpb25zLFxuICAgICk7XG5cbiAgICByZXR1cm4gc2FtZU5hbWUgJiYgc2FtZVZhcmlhYmxlcyAmJiBzYW1lUXVlcnkgJiYgc2FtZUV4dGVuc2lvbnM7XG4gIH1cblxuICBwcml2YXRlIGNvbXBhcmUoZXhwZWN0ZWQ/OiBzdHJpbmcsIHZhbHVlPzogT2JqZWN0IHwgc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgcHJlcGFyZSA9ICh2YWw6IGFueSkgPT5cbiAgICAgIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gdmFsIDogSlNPTi5zdHJpbmdpZnkodmFsKTtcbiAgICBjb25zdCByZWNlaXZlZCA9IHByZXBhcmUodmFsdWUpO1xuXG4gICAgcmV0dXJuICFleHBlY3RlZCB8fCByZWNlaXZlZCA9PT0gZXhwZWN0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogU2VhcmNoIGZvciBvcGVyYXRpb25zIGluIHRoZSBsaXN0IG9mIG9wZW4gb3BlcmF0aW9ucywgYW5kIHJldHVybiBhbGwgdGhhdCBtYXRjaFxuICAgKiB3aXRob3V0IGFzc2VydGluZyBhbnl0aGluZyBhYm91dCB0aGUgbnVtYmVyIG9mIG1hdGNoZXMuXG4gICAqL1xuICBwdWJsaWMgbWF0Y2gobWF0Y2g6IE1hdGNoT3BlcmF0aW9uKTogVGVzdE9wZXJhdGlvbltdIHtcbiAgICBjb25zdCByZXN1bHRzID0gdGhpcy5fbWF0Y2gobWF0Y2gpO1xuXG4gICAgcmVzdWx0cy5mb3JFYWNoKHJlc3VsdCA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMub3Blbi5pbmRleE9mKHJlc3VsdCk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMub3Blbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cGVjdCB0aGF0IGEgc2luZ2xlIG91dHN0YW5kaW5nIHJlcXVlc3QgbWF0Y2hlcyB0aGUgZ2l2ZW4gbWF0Y2hlciwgYW5kIHJldHVyblxuICAgKiBpdC5cbiAgICpcbiAgICogb3BlcmF0aW9ucyByZXR1cm5lZCB0aHJvdWdoIHRoaXMgQVBJIHdpbGwgbm8gbG9uZ2VyIGJlIGluIHRoZSBsaXN0IG9mIG9wZW4gb3BlcmF0aW9ucyxcbiAgICogYW5kIHRodXMgd2lsbCBub3QgbWF0Y2ggdHdpY2UuXG4gICAqL1xuICBwdWJsaWMgZXhwZWN0T25lKG1hdGNoOiBNYXRjaE9wZXJhdGlvbiwgZGVzY3JpcHRpb24/OiBzdHJpbmcpOiBUZXN0T3BlcmF0aW9uIHtcbiAgICBkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uIHx8IHRoaXMuZGVzY3JpcHRpb25Gcm9tTWF0Y2hlcihtYXRjaCk7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMubWF0Y2gobWF0Y2gpO1xuICAgIGlmIChtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEV4cGVjdGVkIG9uZSBtYXRjaGluZyBvcGVyYXRpb24gZm9yIGNyaXRlcmlhIFwiJHtkZXNjcmlwdGlvbn1cIiwgZm91bmQgJHtcbiAgICAgICAgICBtYXRjaGVzLmxlbmd0aFxuICAgICAgICB9IG9wZXJhdGlvbnMuYCxcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRXhwZWN0ZWQgb25lIG1hdGNoaW5nIG9wZXJhdGlvbiBmb3IgY3JpdGVyaWEgXCIke2Rlc2NyaXB0aW9ufVwiLCBmb3VuZCBub25lLmAsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlc1swXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBlY3QgdGhhdCBubyBvdXRzdGFuZGluZyBvcGVyYXRpb25zIG1hdGNoIHRoZSBnaXZlbiBtYXRjaGVyLCBhbmQgdGhyb3cgYW4gZXJyb3JcbiAgICogaWYgYW55IGRvLlxuICAgKi9cbiAgcHVibGljIGV4cGVjdE5vbmUobWF0Y2g6IE1hdGNoT3BlcmF0aW9uLCBkZXNjcmlwdGlvbj86IHN0cmluZyk6IHZvaWQge1xuICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb24gfHwgdGhpcy5kZXNjcmlwdGlvbkZyb21NYXRjaGVyKG1hdGNoKTtcbiAgICBjb25zdCBtYXRjaGVzID0gdGhpcy5tYXRjaChtYXRjaCk7XG4gICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRXhwZWN0ZWQgemVybyBtYXRjaGluZyBvcGVyYXRpb25zIGZvciBjcml0ZXJpYSBcIiR7ZGVzY3JpcHRpb259XCIsIGZvdW5kICR7XG4gICAgICAgICAgbWF0Y2hlcy5sZW5ndGhcbiAgICAgICAgfS5gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgdGhhdCB0aGVyZSBhcmUgbm8gb3V0c3RhbmRpbmcgb3BlcmF0aW9ucy5cbiAgICovXG4gIHB1YmxpYyB2ZXJpZnkoKTogdm9pZCB7XG4gICAgY29uc3Qgb3BlbiA9IHRoaXMub3BlbjtcblxuICAgIGlmIChvcGVuLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIFNob3cgdGhlIG1ldGhvZHMgYW5kIFVSTHMgb2Ygb3BlbiBvcGVyYXRpb25zIGluIHRoZSBlcnJvciwgZm9yIGNvbnZlbmllbmNlLlxuICAgICAgY29uc3Qgb3BlcmF0aW9ucyA9IG9wZW5cbiAgICAgICAgLm1hcCh0ZXN0T3AgPT4gdGVzdE9wLm9wZXJhdGlvbi5vcGVyYXRpb25OYW1lKVxuICAgICAgICAuam9pbignLCAnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEV4cGVjdGVkIG5vIG9wZW4gb3BlcmF0aW9ucywgZm91bmQgJHtvcGVuLmxlbmd0aH06ICR7b3BlcmF0aW9uc31gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGlzRG9jdW1lbnROb2RlKFxuICAgIGRvY09yT3A6IERvY3VtZW50Tm9kZSB8IE9wZXJhdGlvbixcbiAgKTogZG9jT3JPcCBpcyBEb2N1bWVudE5vZGUge1xuICAgIHJldHVybiAhKGRvY09yT3AgYXMgT3BlcmF0aW9uKS5vcGVyYXRpb25OYW1lO1xuICB9XG5cbiAgcHJpdmF0ZSBkZXNjcmlwdGlvbkZyb21NYXRjaGVyKG1hdGNoZXI6IE1hdGNoT3BlcmF0aW9uKTogc3RyaW5nIHtcbiAgICBpZiAodHlwZW9mIG1hdGNoZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gYE1hdGNoIG9wZXJhdGlvbk5hbWU6ICR7bWF0Y2hlcn1gO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hdGNoZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAodGhpcy5pc0RvY3VtZW50Tm9kZShtYXRjaGVyKSkge1xuICAgICAgICByZXR1cm4gYE1hdGNoIERvY3VtZW50Tm9kZWA7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5hbWUgPSBtYXRjaGVyLm9wZXJhdGlvbk5hbWUgfHwgJyhhbnkpJztcbiAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IEpTT04uc3RyaW5naWZ5KG1hdGNoZXIudmFyaWFibGVzKSB8fCAnKGFueSknO1xuXG4gICAgICByZXR1cm4gYE1hdGNoIG9wZXJhdGlvbjogJHtuYW1lfSwgdmFyaWFibGVzOiAke3ZhcmlhYmxlc31gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYE1hdGNoIGJ5IGZ1bmN0aW9uOiAke21hdGNoZXIubmFtZX1gO1xuICAgIH1cbiAgfVxufVxuIl19